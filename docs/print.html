<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>Rust 的命令行应用</title>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="shortcut icon" href="favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
    <link rel="stylesheet" href="css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"
        rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    
    <link rel="stylesheet" href="src/special-content.css">
    

    
</head>

<body class="light">
    <!-- Provide site root to javascript -->
    <script type="text/javascript">var path_to_root = "";</script>

    <!-- Work around some values being stored in localStorage wrapped in quotes -->
    <script type="text/javascript">
        try {
            var theme = localStorage.getItem('mdbook-theme');
            var sidebar = localStorage.getItem('mdbook-sidebar');

            if (theme.startsWith('"') && theme.endsWith('"')) {
                localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
            }

            if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
            }
        } catch (e) { }
    </script>

    <!-- Set the theme before any content is loaded, prevents flash -->
    <script type="text/javascript">
        var theme;
        try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
        if (theme === null || theme === undefined) { theme = 'light'; }
        document.body.className = theme;
        document.querySelector('html').className = theme + ' js';
    </script>

    <!-- Hide / unhide sidebar before it is displayed -->
    <script type="text/javascript">
        var html = document.querySelector('html');
        var sidebar = 'hidden';
        if (document.body.clientWidth >= 1080) {
            try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
            sidebar = sidebar || 'visible';
        }
        html.classList.remove('sidebar-visible');
        html.classList.add("sidebar-" + sidebar);
    </script>

    <nav id="sidebar" class="sidebar" aria-label="Table of contents">
        <ol class="chapter"><li class="affix"><a href="README.zh.html">开始</a></li><li><a href="tutorial/README.zh.html"><strong aria-hidden="true">1.</strong> 15 分钟内完成一个命令行应用程序</a></li><li><ol class="section"><li><a href="tutorial/setup.zh.html"><strong aria-hidden="true">1.1.</strong> 项目设置</a></li><li><a href="tutorial/cli-args.zh.html"><strong aria-hidden="true">1.2.</strong> 对命令行参数解析</a></li><li><a href="tutorial/impl-draft.zh.html"><strong aria-hidden="true">1.3.</strong> 第一次实现</a></li><li><a href="tutorial/errors.zh.html"><strong aria-hidden="true">1.4.</strong> 更好的错误报告</a></li><li><a href="tutorial/output.zh.html"><strong aria-hidden="true">1.5.</strong> 给人和机器的输出</a></li><li><a href="tutorial/testing.zh.html"><strong aria-hidden="true">1.6.</strong> 测试</a></li><li><a href="tutorial/packaging.zh.html"><strong aria-hidden="true">1.7.</strong> 打包和分发一个 Rust 工具</a></li></ol></li><li><a href="in-depth/README.zh.html"><strong aria-hidden="true">2.</strong> 深入的主题</a></li><li><ol class="section"><li><a href="in-depth/signals.zh.html"><strong aria-hidden="true">2.1.</strong> 信号处理</a></li><li><a href="in-depth/config-files.zh.html"><strong aria-hidden="true">2.2.</strong> 使用配置文件</a></li><li><a href="in-depth/exit-code.zh.html"><strong aria-hidden="true">2.3.</strong> 退出代码</a></li><li><a href="in-depth/human-communication.zh.html"><strong aria-hidden="true">2.4.</strong> 与人交流</a></li><li><a href="in-depth/machine-communication.zh.html"><strong aria-hidden="true">2.5.</strong> 与机器交互</a></li><li><a href="in-depth/docs.zh.html"><strong aria-hidden="true">2.6.</strong> CLI 应用程序呈现的文档</a></li></ol></li></ol>
    </nav>

    <div id="page-wrapper" class="page-wrapper">

        <div class="page">
            
            <div id="menu-bar" class="menu-bar">
                <div id="menu-bar-sticky-container">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                            aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <!-- START - Rust Cookbook customization -->
                        <button id="edit-button" class="icon-button" type="button" title="Fork and edit" aria-label="Fork and edit"
                            aria-haspopup="true" aria-expanded="false" aria-controls="edit">
                            <i class="fa fa-edit">Edit</i>
                        </button>
                        <!-- END - Rust Cookbook customization -->
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme"
                            aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Rust 的命令行应用</h1>
                    
                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

            
            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                        aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>
            

            <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
            <script type="text/javascript">
                document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                    link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                });
            </script>

            <!-- // START - Rust Cookbook customization -->
            <script>
                document.getElementById("edit-button").addEventListener("click", function () {
                    var editWindow = window.open("https://github.com/chinanf-boy/cli-wg-zh/edit/master/src/print.md");
                });</script>
            <!-- // END - Rust Cookbook customization -->

            <div id="content" class="content">
                <main>
                    <a class="header" href="#rust-中的命令行应用程序" id="rust-中的命令行应用程序"><h1>Rust 中的命令行应用程序</h1></a>
<p>Rust 是一种静态编译的快速语言，具有强大的工具和快速增长的生态系统。这使得它非常适合编写命令行应用程序：因为它们本就该是小型的、可移植的和快速运行的。命令行应用程序也是开始学习 Rust 的一个很好的方法；或者向您的团队介绍 Rust！</p>
<p>对于初学者来说，用简单的命令行界面（CLI）编写一个程序，会是一个很好的练习，因为他们对该语言还不太熟悉，而这，能开始对它有一种感觉上的习惯。但现在，这个话题有太多方面了，虽然说，往往只有在以后才会显露出来。</p>
<p>这本书的结构是这样的：我们从一个快速教程开始，之后您将得到一个可工作的 CLI 工具。您将了解 rust 的一些核心概念，以及 CLI 应用程序的主要方面。接下来的章节将更详细地介绍其中一些方面。</p>
<p>在深入研究 CLI 应用程序之前，最后一件事是：如果您在本书中发现了错误，或者希望帮助我们为其编写更多内容，您可以找到其源代码。它<a href="https://github.com/rust-lang-nursery/cli-wg">在 CLI wg 存储库中</a>。我们很高兴听到您的反馈！谢谢您！</p>
<a class="header" href="#15-分钟编写命令行应用程序以此学习-rust" id="15-分钟编写命令行应用程序以此学习-rust"><h1>15 分钟编写命令行应用程序，以此学习 Rust</h1></a>
<p>本教程将指导您学习<a href="https://rust-lang.org/">Rust</a>。你大概要花 15 分钟的时间，才能达到你有一个运行程序的点（大约在 1.3 章）。在那之后，我们将继续调整我们的程序，直到我们到达另一个可以输送我们的小工具出去的点。</p>
<p>您将学习如何开始，以及在哪里找到更多信息的所有要点。随意跳过你现在不需要知道的部分，或者挑任何一节来学习。</p>
<aside>
<p><strong>先决条件：</strong> 本教程不会取代编程语言的一般性介绍，并希望您熟悉一些常见的概念。您应该习惯使用命令行/终端。如果你有一些其他语言的经验，这会是首次接触 Rust 的良好例子。</p>
<p><strong>获取帮助：</strong> 如果您在任何时候对所使用的特性，感到不知所措或困惑，请看一下 Rust 附带的大量官方文档，首先是本之书《Rust 编程语言》。它配有大多数的 Rust 配件（<code>rustup doc</code>），可在线获取。<a href="https://doc.rust-lang.org">doc.rust-lang.org</a>.</p>
<p>我们也非常欢迎您提出问题——众所周知，Rust 社区是友好且乐于助人的。看看<a href="https://www.rust-lang.org/community">社区页面</a>看看人们 Rust 讨论区的清单。</p>
</aside>
<p>你想写什么样的项目？我们先从一些简单的事情开始，怎么样：让我们写一个小的<code>grep</code>克隆。这是一个工具，可以给它一个字符串和一个路径，它将只打印包含给定字符串的行。我们称之为<code>grrs</code>（读作“grass”）。</p>
<p>最后，我们希望能够像这样运行我们的工具：</p>
<pre><code class="language-console">$ cat test.txt
foo: 10
bar: 20
baz: 30
$ grrs foo test.txt
foo: 10
$ grrs --help
[some help text explaining the available options]
</code></pre>
<aside class="note">
<p><strong>注：</strong> 这本书是为<a href="https://rust-lang-nursery.github.io/edition-guide/">Rust 2018</a>版本。代码示例也可以在 Rust 2015 版本 上使用，但您可能需要稍微调整一下；例如，添加<code>extern crate foo;</code>调用。</p>
<blockquote>
<p>译者：Rust 语法版本，几乎大多都转向 2018 版本。基本从今以后，也只是一个起到标示的意义。</p>
</blockquote>
<p>确保运行的是 rust 1.31.0（或更高版本），并且<code>Cargo.toml</code>文件的在<code>[package]</code>部分，有<code>edition = &quot;2018&quot;</code>设置。</p>
</aside>
<a class="header" href="#项目设置" id="项目设置"><h1>项目设置</h1></a>
<p>如果你还没有准备好，情在你的电脑上<a href="https://www.rust-lang.org/tools/install">安装螃蟹-Rust</a>(它应该只需要几分钟)。
之后，我们打开一个终端，并<code>cd</code>到接下来教程代码(你想)放置的目录。</p>
<blockquote>
<p>译者：螃蟹是 Rust 的吉祥物，而 Rust 也有螃蟹的意思，所以，让我们开始尝尝螃蟹吧。</p>
</blockquote>
<p>在目录中先运行<code>cargo new grrs</code>，<strong>grrs</strong>是编程存进的目录，若是查看<code>grrs</code>目录(结构)，你会发现一个典型的 Rust 项目装置。</p>
<ul>
<li>一个<code>Cargo.toml</code>文件，它包含我们项目的元数据。还有我们使用的依赖项/外部 库(或者说 crate-箱子)。</li>
<li>一个<code>src/main.rs</code>文件，它是我们(主)二进制文件的入口文件。</li>
</ul>
<p>如果你可以在<code>grrs</code>目录执行<code>cargo run</code>，你会得到一个“Hello World”，那说明你都准备好了。</p>
<a class="header" href="#它可能会是什么样子" id="它可能会是什么样子"><h2>它可能会是什么样子</h2></a>
<pre><code class="language-console">$ cargo new grrs
     Created binary (application) `grrs` package
$ cd grrs/
$ cargo run
   Compiling grrs v0.1.0 (/Users/pascal/code/grrs)
    Finished dev [unoptimized + debuginfo] target(s) in 0.70s
     Running `target/debug/grrs`
Hello, world!
</code></pre>
<a class="header" href="#对命令行参数解析" id="对命令行参数解析"><h1>对命令行参数解析</h1></a>
<p>对 cli 工具的典型调用，如下所示：</p>
<pre><code class="language-console">$ grrs foobar test.txt
</code></pre>
<p>我们希望我们的程序，可以查阅<code>test.txt</code>，并打印出包含<code>foobar</code>的那些行。但是我们如何得到这两个值呢？</p>
<p>(调用的)程序名，之后的文本，通常称为“命令行参数”或“命令行标志”（尤其是当它们看起来像<code>--this</code>的时候）。在内部，操作系统通常将它们表示为字符串列表，大致来说，它们由空格分隔。</p>
<p>这些参数有很多考虑方式，以及如何将它们解析为更容易处理的内容。您还需要告诉程序的用户，他们需要给出哪些参数，以及期望的格式。</p>
<a class="header" href="#获取参数" id="获取参数"><h2>获取参数</h2></a>
<p>标准库包含函数<a href="https://doc.rust-lang.org/1.31.0/std/env/fn.args.html"><code>std::env::args()</code></a>，这给了你一个<a href="https://doc.rust-lang.org/1.31.0/std/iter/index.html">迭代器</a>，含有用户给出的命令行参数。第一个条目（在索引处<code>0</code>）将是您的程序所称的名称（例如<code>grrs</code>），接下去的条目是用户随后写下的。</p>
<p>以这种方式，获得原始参数非常容易：</p>
<pre><code class="language-rust ignore">let pattern = std::env::args().nth(1).expect(&quot;no pattern given&quot;);
let path = std::env::args().nth(2).expect(&quot;no path given&quot;);
</code></pre>
<a class="header" href="#作为数据类型的-cli-参数" id="作为数据类型的-cli-参数"><h2>作为数据类型的 CLI 参数</h2></a>
<p>与其把它们看作一堆文本，不如把 cli 参数看作表示程序输入的自定义数据类型。</p>
<p>瞧瞧<code>grrs foobar test.txt</code>：有两个参数，第一个是<code>pattern</code>(模式)（要查找的字符串），然后<code>path</code>(路径)（要查找的文件）。</p>
<p>我们还能对他们说些什么呢？嗯，首先，两者都是必需的。我们还没有讨论任何默认值，因此我们希望用户始终提供两个值。此外，我们可以稍微介绍一下它们的类型：模式应该是一个字符串，而第二个参数应该是一个文件的路径。</p>
<p>在 Rust 中，围绕所处理的数据，构建程序是很常见的，因此这种查看 CLI 参数的方式非常适合。让我们从这个开始：</p>
<pre><code class="language-rust ignore">struct Cli {
    pattern: String,
    path: std::path::PathBuf,
}

</code></pre>
<p>这定义了一个新的结构（一个<a href="https://doc.rust-lang.org/1.31.0/book/ch05-00-structs.html"><code>struct</code></a>）它有两个字段用于存储数据：<code>pattern</code>和<code>path</code>。</p>
<aside>
<p><strong>旁白：</strong>
<a href="https://doc.rust-lang.org/1.31.0/std/path/struct.PathBuf.html"><code>PathBuf</code></a>就像一个<a href="https://doc.rust-lang.org/1.31.0/std/string/struct.String.html"><code>String</code></a>，但用作跨平台工作的文件系统路径。</p>
</aside>
<p>现在，我们仍然需要得到进入程序的实际参数。一种选择是手动解析操作系统获得的字符串列表，并自己构建结构。它看起来像这样：</p>
<pre><code class="language-rust ignore">let pattern = std::env::args().nth(1).expect(&quot;no pattern given&quot;);
let path = std::env::args().nth(2).expect(&quot;no path given&quot;);
let args = Cli {
    pattern: pattern,
    path: std::path::PathBuf::from(path),
};
</code></pre>
<p>这样是可以的，但不太方便。但你要如何处理支持<code>--pattern=&quot;foo&quot;</code>或<code>--pattern &quot;foo&quot;</code>的要求？你又如何实现<code>--help</code>？</p>
<a class="header" href="#使用-structopt-分析-cli-参数" id="使用-structopt-分析-cli-参数"><h2>使用 StructOpt 分析 CLI 参数</h2></a>
<p>一个更好的方法是运用一个可用库，当然还有许多其他可用库。最流行的用于分析命令行参数的库称为<a href="https://clap.rs/"><code>clap</code></a>. 它具有您所期望的所有功能，包括对，子命令的支持、shell 补全和伟大的帮助消息。</p>
<p>这个<a href="https://docs.rs/structopt"><code>structopt</code></a>箱子建立在<code>clap</code>之上，并提供一个“derive”宏，用来生成<code>struct</code>定义的有关<code>clap</code>代码。这很好：我们所要做的就是注释一个结构，而它将生成为，把(命令行)参数解析到字段中的代码。</p>
<p>我们先导入<code>structopt</code>，具体先在<code>Cargo.toml</code>文件的<code>[dependencies]</code>部分，添加<code>structopt = &quot;0.2.10&quot;</code>。</p>
<p>现在，在我们的代码中，写<code>use structopt::StructOpt;</code>，并添加<code>#[derive(StructOpt)]</code>，到我们<code>struct Cli</code>的上面。同时，我们还将编写一些文档注释。</p>
<p>看起来像这样：</p>
<pre><code class="language-rust ignore">use structopt::StructOpt;

/// Search for a pattern in a file and display the lines that contain it.
#[derive(StructOpt)]
struct Cli {
    /// The pattern to look for
    pattern: String,
    /// The path to the file to read
    #[structopt(parse(from_os_str))]
    path: std::path::PathBuf,
}

</code></pre>
<aside class="node">
<p><strong>旁注：</strong> （StructOpt）有很多自定义属性可以添加到字段中。例如，我们添加了一个<code>PathBuf</code>类型，让 structopt 解析。要说您想在后面的参数中，使用此字段<code>-o</code>或<code>--output</code>，您可以添加<code>#[structopt(short = &quot;o&quot;, long = &quot;output&quot;)]</code>。 有关详细信息，请参阅<a href="https://docs.rs/structopt">StructOpt 文档</a>。</p>
</aside>
<p>就在<code>Cli</code>结构下面，我们的模板包含<code>main</code>函数。当程序启动时，它将调用此函数。第一行是：</p>
<pre><code class="language-rust ignore">fn main() {
    let args = Cli::from_args();
}
</code></pre>
<p>这将尝试将(命令行)参数解析为<code>Cli</code>结构。</p>
<p>但如果失败了呢？下面就是这方式的好处：Clap 知道应期望哪个字段，以及它们期望的格式是什么。它可以自动生成一个<code>--help</code>信息，以及一些重大错误(信息)，建议您应把<code>--output</code>，而不是<code>--putput</code>作为传递参数。</p>
<aside class="note">
<p><strong>旁注：</strong> 这个<code>from_args</code>方法就是给<code>main</code>函数使用的。当失败时，它将打印出一个错误或帮助消息，并立即退出程序。请不要在其他地方使用它！</p>
</aside>
<a class="header" href="#这就是它的样子" id="这就是它的样子"><h2>这就是它的样子</h2></a>
<p>在没有任何参数的情况下，运行它：</p>
<pre><code class="language-console">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 10.16s
     Running `target/debug/grrs`
error: The following required arguments were not provided:
    &lt;pattern&gt;
    &lt;path&gt;

USAGE:
    grrs &lt;pattern&gt; &lt;path&gt;

For more information try --help
</code></pre>
<p>我们可以在使用时传递参数<code>cargo run</code>直接写在后面<code>--</code>：</p>
<pre><code class="language-console">$ cargo run -- some-pattern some-file
    Finished dev [unoptimized + debuginfo] target(s) in 0.11s
     Running `target/debug/grrs some-pattern some-file`
</code></pre>
<p>如您所见，没有输出。很好：这意味着没有错误，我们的程序结束了。</p>
<aside class="exercise">
<p><strong>读者练习：</strong> 让此程序输出其(命令行)参数！</p>
</aside>
<a class="header" href="#grrs首次实现" id="grrs首次实现"><h1><em>grrs</em>首次实现</h1></a>
<p>在关于命令行参数的上一章之后，我们有了输入数据，可以开始编写实际的工具。我们的<code>main</code>函数当前只包含这些：</p>
<pre><code class="language-rust ignore">let args = Cli::from_args();
</code></pre>
<p>我们先打开我们得到的文件。</p>
<pre><code class="language-rust ignore">let content = std::fs::read_to_string(&amp;args.path)
    .expect(&quot;could not read file&quot;);
</code></pre>
<aside>
<p><strong>旁白：</strong> 看到了吗？这里的<a href="https://doc.rust-lang.org/1.31.0/std/result/enum.Result.html#method.expect"><code>.expect</code></a>方法？这是一个快捷函数，可以退出程序。当无法读取值（在本例中是输入的文件）时，该函数将使程序立即退出。它不是很漂亮，在下一章[更好的错误报告]我们将研究如何改进这一点。</p>
</aside>
<p>现在，让我们对这些行，进行迭代，并打印每个包含我们的模式的行：</p>
<pre><code class="language-rust ignore">for line in content.lines() {
    if line.contains(&amp;args.pattern) {
        println!(&quot;{}&quot;, line);
    }
}
</code></pre>
<p>试一试：<code>cargo run -- main src/main.rs</code>。现在应该工作了！</p>
<aside class="exercise">
<p><strong>读者练习：</strong> 这不是最好的实现：会先把整个文件读取到内存中——不管文件有多大。找到一种方法来优化它！（一个想法可能是使用<a href="https://doc.rust-lang.org/1.31.0/std/io/struct.BufReader.html"><code>BufReader</code></a>，而不是<code>read_to_string()</code>）</p>
</aside>
<a class="header" href="#更好的错误报告" id="更好的错误报告"><h1>更好的错误报告</h1></a>
<p>我们只能接受这样一个事实：错误会发生。与许多其他语言不同的是，在使用 rust 时，很难不注意和不处理这个事实：因为无一例外，所有可能的错误状态，通常都编码在函数的返回类型中。</p>
<a class="header" href="#result" id="result"><h2>Result</h2></a>
<p>像<a href="https://doc.rust-lang.org/1.31.0/std/fs/fn.read_to_string.html"><code>read_to_string</code></a>这样的函数，是不返回字符串的。相反，它返回<a href="https://doc.rust-lang.org/1.31.0/std/result/index.html"><code>Result</code></a>，其中(一个是)包含<code>String</code>或(另一种是)某类型的错误（在本例子是<a href="https://doc.rust-lang.org/1.31.0/std/io/type.Result.html"><code>std::io::Error</code></a>）</p>
<p>你怎么知道它是什么？因为啊，<code>Result</code>(其实)是一个<code>enum</code>(枚举)，您可以使用<code>match</code>，检查它是哪种变体：</p>
<pre><pre class="playpen"><code class="language-rust no_run">
# #![allow(unused_variables)]
#fn main() {
let result = std::fs::read_to_string(&quot;test.txt&quot;);
match result {
    Ok(content) =&gt; { println!(&quot;File content: {}&quot;, content); }
    Err(error) =&gt; { println!(&quot;Oh noes: {}&quot;, error); }
}
#}</code></pre></pre>
<aside>
<p><strong>旁白：</strong> 不知道 Rust 的 enum 是什么，也不知道它们是如何工作？<a href="https://doc.rust-lang.org/1.31.0/book/ch06-00-enums.html">查看 Rust 之书的有关章节</a>，跟上，跟上。</p>
</aside>
<a class="header" href="#展开unwrap" id="展开unwrap"><h2>展开(Unwrap)</h2></a>
<p>现在，我们可以访问文件的内容，但在<code>match</code>区块之后我们不能肯定(它的返回类型)。为此，我们需要以某种方式处理错误案例。这里的挑战在于<code>match</code>块的所有条件语句(或是臂)，需要返回相同类型的内容。但有一个巧妙的方法可以解决这个问题：</p>
<blockquote>
<p>译：Rust 常把 match 的条件语句，说成 手臂(arm)，看起来还挺像的。</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust no_run">
# #![allow(unused_variables)]
#fn main() {
let result = std::fs::read_to_string(&quot;test.txt&quot;);
let content = match result {
    Ok(content) =&gt; { content },
    Err(error) =&gt; { panic!(&quot;Can't deal with {}, just exit here&quot;, error); }
};
println!(&quot;file content: {}&quot;, content); // 使用 content
#}</code></pre></pre>
<p>我们可以在<code>match</code>区块之后，使用<code>content</code>的字符串(String 类型)。如果<code>result</code>是错误（Err），则字符串将不存在。但因为程序在到达使用<code>content</code>点之前，就退出了，所以不会有问题。</p>
<p>这可能看起来很刚烈，但很方便。如果您的程序需要读取该文件，并且如果该文件不存在，无法执行任何操作，那么退出是一种有效的策略。甚至还有一个针对<code>Result</code>的快捷方式，就是调用<code>unwrap</code>：</p>
<pre><pre class="playpen"><code class="language-rust no_run">
# #![allow(unused_variables)]
#fn main() {
let content = std::fs::read_to_string(&quot;test.txt&quot;).unwrap();
#}</code></pre></pre>
<a class="header" href="#不必惊慌" id="不必惊慌"><h2>不必惊慌</h2></a>
<p>当然，中止/崩溃程序并不是处理错误的唯一方法。不用<code>panic!</code>，我们也可以简单使用<code>return</code>：</p>
<pre><pre class="playpen"><code class="language-rust no_run"># fn main() -&gt; Result&lt;(), Box&lt;std::error::Error&gt;&gt; {
let result = std::fs::read_to_string(&quot;test.txt&quot;);
let _content = match result {
    Ok(content) =&gt; { content },
    Err(error) =&gt; { return Err(error.into()); }
};
# Ok(())
# }
</code></pre></pre>
<p>但是，这会改变函数所需的返回类型。实际上，在我们的示例中一直隐藏着一些东西：这个代码所在的函数签名。而在上一个<code>return</code>例子中，它变得很重要。这是<em>完整</em>例子：</p>
<pre><pre class="playpen"><code class="language-rust no_run">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let result = std::fs::read_to_string(&quot;test.txt&quot;);
    let content = match result {
        Ok(content) =&gt; { content },
        Err(error) =&gt; { return Err(error.into()); }
    };
    println!(&quot;file content: {}&quot;, content);
    Ok(())
}
</code></pre></pre>
<p>我们的返回类型是一个<code>Result</code>！这就是为什么我们可以在第二个 match 臂上，写<code>return Err(error);</code>。看看为啥有个<code>Ok(())</code>在底部？因它是函数的默认返回值，表示“结果(Result)正常<code>Ok</code>，且没有内容<code>()</code>”。</p>
<aside>
<p><strong>旁白：</strong> 为什么这不是写为<code>return Ok(());</code>？很容易——这也是完全有效的。在 Rust 中，作用域内的最后一个表达式(不加<code>;</code>结尾)是它的返回值，并且习惯上省略不必要的<code>return</code>。</p>
</aside>
<a class="header" href="#问号" id="问号"><h2>问号<code>?</code></h2></a>
<p>就像<code>match</code>中，可在错误臂调用<code>.unwrap()</code>，作为<code>panic!</code>一样，我们的<code>match</code>有另一个能在错误臂中<code>return</code>的，就是<code>?</code>。</p>
<p>没错，<code>?</code>。可以将此运算符附加到类型<code>Result</code>的值上，Rust 会在内部扩展为类似我们刚刚编写的<code>match</code>语句。</p>
<p>试一试：</p>
<pre><pre class="playpen"><code class="language-rust no_run">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let content = std::fs::read_to_string(&quot;test.txt&quot;)?;
    println!(&quot;file content: {}&quot;, content);
    Ok(())
}
</code></pre></pre>
<p>非常简洁！</p>
<aside>
<p><strong>旁白：</strong> 这里还发生了一些不需要理解的事情。例如，我们的<code>main</code>函数是<code>Box&lt;dyn std::error::Error&gt;</code>. 但我们已经看到<code>read_to_string</code>是返回<a href="https://doc.rust-lang.org/1.31.0/std/io/type.Result.html"><code>std::io::Error</code></a>的。这是因为<code>?</code>扩展了<em>转换</em>错误类型的代码。</p>
<p><code>Box&lt;dyn std::error::Error&gt;</code>也是一种有趣的类型。这是一个<code>Box</code>可以包含<em>任何</em>实现标准<a href="https://doc.rust-lang.org/1.31.0/std/error/trait.Error.html"><code>Error</code></a>trait 的类型。这意味着基本上所有的错误都可以放入这个 Box 中，所以我们可以把<code>?</code>，用在会返回<code>Result</code>的所有常规函数上。</p>
</aside>
<a class="header" href="#提供上下文" id="提供上下文"><h2>提供上下文</h2></a>
<p>在你的<code>main</code>函数使用<code>?</code>时出现错误，是可以的，但不太好。例如：当你运行<code>std::fs::read_to_string(&quot;test.txt&quot;)?</code>，但是文件<code>test.txt</code>不存在，您将得到以下输出：</p>
<blockquote>
<blockquote>
<p>Error: Os { code: 2, kind: NotFound, message: “No such file or directory” }</p>
</blockquote>
</blockquote>
<p>如果代码中没有包含文件名，就很难判断哪个文件是<code>NotFound</code>。有多种方法可以解决这个问题。</p>
<p>例如，我们可以创建自己的错误类型，然后使用它来构建自定义错误消息：</p>
<pre><code class="language-rust ignore">#[derive(Debug)]
struct CustomError(String);

fn main() -&gt; Result&lt;(), CustomError&gt; {
    let path = &quot;test.txt&quot;;
    let content = std::fs::read_to_string(path)
        .map_err(|err| CustomError(format!(&quot;Error reading `{}`: {}&quot;, path, err)))?;
    println!(&quot;file content: {}&quot;, content);
    Ok(())
}

</code></pre>
<p>现在，运行此命令，我们将收到自定义错误消息：</p>
<blockquote>
<p>Error: CustomError(”Error reading <code>test.txt</code>: No such file or directory (os error 2)”)</p>
</blockquote>
<p>不是说很漂亮，但稍后我们可以为我们的类型，简单调整调试输出。</p>
<p>这种模式实际上很常见。但它有一个问题：我们不存储原始错误，只存储它的字符串表示。常用的<a href="https://docs.rs/failure"><code>failure</code></a>箱子有一个很好的解决方案：类似于我们的<code>CustomError</code>类型，但它有一个<a href="https://docs.rs/failure/0.1.3/failure/struct.Context.html"><code>Context</code></a>会包含说明和原始错误的类型。箱子也带来了一个扩展 trait <a href="https://docs.rs/failure/0.1.3/failure/trait.ResultExt.html"><code>ResultExt</code></a>），可以为<code>Result</code>加上<a href="https://docs.rs/failure/0.1.3/failure/trait.ResultExt.html#tymethod.context"><code>context()</code></a>和<a href="https://docs.rs/failure/0.1.3/failure/trait.ResultExt.html#tymethod.with_context"><code>with_context()</code></a>方法。</p>
<p>为了将这些打包的错误类型，转换为人类真正想要读取的内容，我们可以进一步添加<a href="https://docs.rs/exitfailure"><code>exitfailure</code></a>箱子，并使用其类型作为我们<code>main</code>函数的返回类型。</p>
<p>让我们先导入这些箱子，也就是在<code>Cargo.toml</code>文件的<code>[dependencies]</code>部分，添加<code>failure = &quot;0.1.5&quot;</code>和<code>exitfailure = &quot;0.5.1&quot;</code>。</p>
<p>完整的示例如下：</p>
<pre><code class="language-rust ignore">use failure::ResultExt;
use exitfailure::ExitFailure;

fn main() -&gt; Result&lt;(), ExitFailure&gt; {
    let path = &quot;test.txt&quot;;
    let content = std::fs::read_to_string(path)
        .with_context(|_| format!(&quot;could not read file `{}`&quot;, path))?;
    println!(&quot;file content: {}&quot;, content);
    Ok(())
}

</code></pre>
<p>这将打印一个错误：</p>
<blockquote>
<p>Error: could not read file <code>test.txt</code><br />
Info: caused by No such file or directory (os error 2)</p>
</blockquote>
<a class="header" href="#输出" id="输出"><h1>输出</h1></a>
<a class="header" href="#打印hello-world" id="打印hello-world"><h2>打印“Hello World”</h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
println!(&quot;Hello World&quot;);
#}</code></pre></pre>
<p>嗯，很简单。很好，下一个话题。</p>
<a class="header" href="#使用-println" id="使用-println"><h2>使用 println</h2></a>
<p>你大概可以用<code>println!</code>宏打印你喜欢的所有东西。这个宏有一些非常惊人的功能，但也有一个特殊的语法。它期望您编写一个字符串文字作为第一个参数，其中包含由后面参数的参数值填充的占位符。</p>
<p>例如：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 42;
println!(&quot;My lucky number is {}.&quot;, x);
#}</code></pre></pre>
<p>将打印</p>
<pre><code class="language-console">My lucky number is 42.
</code></pre>
<p>上面的字符串中大括号（<code>{}</code>）是这些占位符之一。这是默认的占位符类型，尝试以人类可读的方式打印值。对于数字和字符串，这很好地工作，但并非所有类型都能做到这一点。这就是为什么还存在一个“调试表示法”，就是通过在大括号填充占位符：<code>{:?}</code>。</p>
<p>例如，</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let xs = vec![1, 2, 3];
println!(&quot;The list is: {:?}&quot;, xs);
#}</code></pre></pre>
<p>将打印</p>
<pre><code class="language-console">The list is: [1, 2, 3]
</code></pre>
<p>如果您希望自己的数据类型可以打印用于调试和日志记录，那么在大多数情况下，您可以添加<code>#[derive(Debug)]</code>在他们的定义之上。</p>
<aside>
<p><strong>旁白：</strong> “用户友好”的打印是使用<a href="https://doc.rust-lang.org/1.31.0/std/fmt/trait.Display.html"><code>Display</code></a> trait，调试输出（人类可读，但面向开发人员）是使用<a href="https://doc.rust-lang.org/1.31.0/std/fmt/trait.Debug.html"><code>Debug</code></a> trait。您可以在<a href="https://doc.rust-lang.org/1.31.0/std/fmt/index.html"><code>std::fmt</code>模块的文档</a>找到，有关<code>println!</code>使用语法的更多信息。</p>
</aside>
<a class="header" href="#打印错误" id="打印错误"><h2>打印错误</h2></a>
<p>错误的打印应该用<code>stderr</code>，让用户和其他工具更容易将输出，传输到文件或更多工具。</p>
<aside>
<p><strong>旁白：</strong> 在大多数操作系统上，程序可以写入两个输出流，<code>stdout</code>和<code>stderr</code>。 <code>stdout</code>是程序的实际输出，而<code>stderr</code>则允许错误和其他消息，并与<code>stdout</code>分隔开来。这样的话，当是错误的事件发生，(错误)输出就能存储到一个文件或管道到其他程序。</p>
</aside>
<p>在 Rust 中，由<code>println!</code>和<code>eprintln!</code>完成，前者打印到<code>stdout</code>，而后者打印到<code>stderr</code>。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
println!(&quot;This is information&quot;);
eprintln!(&quot;This is an error! :(&quot;);
#}</code></pre></pre>
<aside>
<p><strong>当心</strong>：打印<a href="https://en.wikipedia.org/wiki/ANSI_escape_code">转义代码</a>可能是危险的，会把用户的终端置于一个奇怪的状态，所以手动打印总要小心为妙。</p>
<p>理想情况下，你应该使用一个箱子<code>ansi_term</code>，当处理原始转义代码，能让你（和你的用户）日子更简单。</p>
</aside>
<a class="header" href="#一份打印性能的报告" id="一份打印性能的报告"><h2>一份打印性能的报告</h2></a>
<p>如果你尝试重复<code>println!</code>的话，你会发现打印到终端非常缓慢！很容易就成为以快速为目标的程序的瓶颈。要加速，这里有两件你能做的事。</p>
<p>第一，您可能想要减少终端实际的刷新（flush）。而每一个<code>println!</code>会告诉系统<em>每次</em>都刷新一下终端，因为常见功能就是要打印一个新行。如果你并不需要这些，你可以用一个默认的 8 kB 缓冲<a href="https://doc.rust-lang.org/1.31.0/std/io/struct.BufWriter.html"><code>BufWriter</code></a>，去包裹你的<code>stdout</code>控制器。（你仍可以调用<code>BufWriter</code>的<code>.flush()</code>，若是你想要立即打印的话。)</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io::{self, Write};

let stdout = io::stdout(); // 获得 stdout 实体
let mut handle = io::BufWriter::new(stdout); // 可选: 把  stdout 的 控制权 包裹进一个 buffer
writeln!(handle, &quot;foo: {}&quot;, 42); // 可加上 `?`， 若你关心错误的话。
#}</code></pre></pre>
<p>第二，获得<code>stdout</code>(或<code>stderr</code>)的一个锁也有用，并使用<code>writeln!</code>直接打印到它。这可以防止系统一遍遍重复对<code>stdout</code>上锁和解锁。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io::{self, Write};

let stdout = io::stdout(); // 获得 stdout 实体
let mut handle = stdout.lock(); // 获得它的一个锁
writeln!(handle, &quot;foo: {}&quot;, 42); // 可加上 `?`， 若你关心错误的话。
#}</code></pre></pre>
<p>你也可以把两种方法结合起来。</p>
<a class="header" href="#显示一个进度条" id="显示一个进度条"><h2>显示一个进度条</h2></a>
<p>一些 CLI 应用程序运行不到一秒，有些则以分钟或小时计算。
如果你编写的是后者，你可能会想要告诉你的用户，程序的进展如何。
针对这个，你应该试着打印有用的更新状态，想法是能让用户容易接受。</p>
<p>使用<a href="https://crates.io/crates/indicatif">indicatif</a>箱，你可以为你的程序添加进度条和小提示。
下面是个快餐示例：</p>
<pre><code class="language-rust ignore">fn main() {
    let pb = indicatif::ProgressBar::new(100);
    for i in 0..100 {
        do_hard_work();
        pb.println(format!(&quot;[+] finished #{}&quot;, i));
        pb.inc(1);
    }
    pb.finish_with_message(&quot;done&quot;);
}
</code></pre>
<p>欲了解更多的信息，请看<a href="https://docs.rs/indicatif">文档</a>和<a href="https://github.com/mitsuhiko/indicatif/tree/master/examples">例子</a>。</p>
<a class="header" href="#日志记录" id="日志记录"><h2>日志记录</h2></a>
<p>要让我们程序正在发生的事情，更容易理解。我们会想要加上一些记录语句。这是最常用的方式了，但接下来的时间，它会却能带给超大的帮助。在某些考虑下，记录就如同<code>println</code>一样，除了你可以指定信息的重要性，常见的级别有 <em>error</em>, <em>warn</em>, <em>info</em>, <em>debug</em>, 和 <em>trace</em> (<em>error</em>具有最高优先级，<em>trace</em>最低的)。</p>
<p>要将简单的日志记录添加到您的应用程序，你需要两个帮手：<a href="https://crates.io/crates/log">log</a>箱子(配有日志级别命名的宏）和一个 <em>适配器(adapter)</em>，也就是把日志输出到有用的地方。日志适配器的功能是很灵活：你想想，不仅可以把日志输出到终端，还可以是<a href="https://en.wikipedia.org/wiki/Syslog">syslog</a>，或中央日志服务器。</p>
<p>鉴于我们现在只关心编写一个命令行应用，适配器简单用<a href="https://crates.io/crates/env_logger">env_logger</a>就好。它的名称叫做<code>env</code>，因它可能使用环境变量，来指定你命令行想要记录的部分。（当然，还有日志的级别）它会有一个时间戳和来自哪个模块，帮你前缀化你的信息，也可以简单配置日志的输出。</p>
<p>这里有一个简单的例子:</p>
<pre><code class="language-rust ignore">use log::{info, warn};

fn main() {
    env_logger::init();
    info!(&quot;starting up&quot;);
    warn!(&quot;oops, nothing implemented!&quot;);
}

</code></pre>
<p>假设你有这个<code>src/bin/output-log.rs</code>文件,</p>
<p>在 Linux 和 macOS，您可以像这样运行它:</p>
<pre><code class="language-console">$ env RUST_LOG=output_log=info cargo run --bin output-log
    Finished dev [unoptimized + debuginfo] target(s) in 0.17s
     Running `target/debug/output-log`
[2018-11-30T20:25:52Z INFO  output_log] starting up
[2018-11-30T20:25:52Z WARN  output_log] oops, nothing implemented!
</code></pre>
<p>在 Windows PowerShell，您可以像这样运行它:</p>
<pre><code class="language-console">$ $env:RUST_LOG=&quot;output_log=info&quot; //set the env var for the current session
$ cargo run --bin output-log
    Finished dev [unoptimized + debuginfo] target(s) in 0.17s
     Running `target/debug/output-log.exe`
[2018-11-30T20:25:52Z INFO  output_log] starting up
[2018-11-30T20:25:52Z WARN  output_log] oops, nothing implemented!
</code></pre>
<p>在 Windows CMD，您可以像这样运行它:</p>
<pre><code class="language-console">$ rem set the env var for the current session
$ set RUST_LOG=output_log=info
$ cargo run --bin output-log
    Finished dev [unoptimized + debuginfo] target(s) in 0.17s
     Running `target/debug/output-log.exe`
[2018-11-30T20:25:52Z INFO  output_log] starting up
[2018-11-30T20:25:52Z WARN  output_log] oops, nothing implemented!
</code></pre>
<p><code>RUST_LOG</code>是环境变量的名字，你可以用来设置你的日志配置。<code>env_logger</code>还包含一个构建器，所以你可以用程序调整这个配置，就比如说，默认级别信息为 <em>info</em> 。</p>
<p>有很多日志适配器的替代品，当然还有<code>log</code>的替换或扩展。
如果你知道你的应用要记录很多，请确保日志清晰明了，让你的用户日子舒服些。</p>
<aside>
<p><strong>提示：</strong> 经验表明，即使是小的 CLI，但有用的话，使用寿命可能是以年计的。（即使是作为一个暂时的解决方案。）如果你的应用不能工作了，和某人（或是未来的你）需要理解应用，那么<code>--verbose</code>标志的详细日志输出，就能让这个过程缩短。<a href="https://crates.io/crates/clap-verbosity-flag">clap-verbosity-flag</a>箱子包含一个添加<code>--verbose</code>的方法，仅限该项目使用的是<code>structopt</code>。</p>
</aside>
<a class="header" href="#测试" id="测试"><h1>测试</h1></a>
<p>经过几十年的软件开发，人们发现了一个事实：未经测试的软件不会工作。（许多人甚至会说：“大多数测试过的软件也不会工作。”但我们都是乐观主义者，对吧？）因此，为了确保您的程序完成您期望它做的，测试它是明智的选择。</p>
<p>一个简单的方法是写一个<code>README</code>文件，描述程序应执行的操作。当您准备好发布新版本时，请通过<code>README</code>确保行为仍如预期。您也可以写下程序对错误输入的反应，把这当成一个更严格的练习。</p>
<p>还有一个好主意：在你写代码之前，就构思<code>README</code>。</p>
<aside>
<p><strong>旁白：</strong> 可以看看<a href="TDD">测试驱动开发</a>，如果你还没头绪的话。</p>
</aside>
<a class="header" href="#自动化测试" id="自动化测试"><h2>自动化测试</h2></a>
<p>现在，这一切都变得很好，且花式多样，但要手工做这些吗？那可能需要很多时间。与此同时，许多人开始喜欢告诉计算机，帮他们做事情。我们来谈谈如何自动化这些测试。</p>
<p>Rust 有一个内置的测试框架，所以我们从编写第一个测试开始：</p>
<pre><code class="language-rust ignore">#[test]
fn check_answer_validity() {
    assert_eq!(answer(), 42);
}
</code></pre>
<p>你可以把这段代码放到几乎所有的文件中，<code>cargo test</code>会找到并运行它。这里的关键是<code>#[test]</code>属性。它允许’构建系统’发现这些函数，并将它们作为测试运行，以验证它们不会恐慌崩溃。</p>
<aside class="exercise">
<p><strong>读者练习：</strong> 使此测试工作。</p>
<p>您应该以如下输出结束：</p>
<pre><code class="language-text">running 1 test
test check_answer_validity ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
</aside>
<p>现在我们看到了我们可以<em>怎样</em>编写测试，我们还需要弄清楚要测试<em>什么</em>。正如您所看到的，编写函数断言(assert)相当容易。但是，CLI 应用程序通常不止一个函数！更糟糕的是，它经常需要处理用户输入、读文件和写输出。</p>
<a class="header" href="#使代码具备可测试性" id="使代码具备可测试性"><h2>使代码具备可测试性</h2></a>
<p>测试功能有两种互补的方法：测试构建完整应用程序的小单元，这些方法称为“单元测试”。还有“从外部”测试<strong>最终</strong>应用程序，称为“黑盒测试”或“集成测试”。让我们从第一个开始。</p>
<p>为了弄清楚我们应该测试什么，让我们看看我们的程序功能是什么。<code>grrs</code>主要的工作就是，应该打印出与给定(文本)模式匹配的行。那么，让我们为这个(功能)编写单元测试：我们希望确保我们最重要的一段逻辑代码能够正常工作，并且我们希望这，以一种不会依赖于周围的任何设置代码的方式进行（例如，处理 cli 参数的代码）。</p>
<p>回到我们<code>grrs</code>的<a href="tutorial/impl-draft.zh.html">首次实现一文</a>，我们将此代码块添加到<code>main</code>函数：</p>
<pre><code class="language-rust ignore">// ...
for line in content.lines() {
    if line.contains(&amp;args.pattern) {
        println!(&quot;{}&quot;, line);
    }
}
</code></pre>
<p>遗憾的是，这并不容易测试。首先，它在 main 函数中，所以我们不能轻易地调用它。通过将这段代码移动到一个函数（本例子是<code>find_matches</code>）中，可以很容易地解决这一问题：</p>
<pre><pre class="playpen"><code class="language-rust no_run">
# #![allow(unused_variables)]
#fn main() {
fn find_matches(content: &amp;str, pattern: &amp;str) {
    for line in content.lines() {
        if line.contains(pattern) {
            println!(&quot;{}&quot;, line);
        }
    }
}
#}</code></pre></pre>
<p>现在，我们可以在测试中调用这个函数，看看它的输出是什么：</p>
<pre><code class="language-rust ignore">#[test]
fn find_a_match() {
    find_matches(&quot;lorem ipsum\ndolor sit amet&quot;, &quot;lorem&quot;);
    assert_eq!( // uhhhh
</code></pre>
<p>或者… 我们可以吗？现在嘛，<code>find_matches</code>会直接打印到<code>stdout</code>，即终端上显示。我们不太能在测试中轻易捕捉它！这是在先实现，后编写测试时，经常出现的一个问题：因我们已经编写了一个函数，而它与使用它的上下文紧密集成(或是粘连)在一起。</p>
<aside class="note">
<p><strong>注：</strong> 在编写小型 CLI 应用程序时，这完全可以。没有必要所有东西都可以测试！而且，重要的是要考虑代码的哪些部分，可能需要编写单元测试。虽然我们(似乎)看到，可以很容易将此函数更改为可测试的(闭环状态)，但情况并非总是如此。</p>
</aside>
<p>好吧，我们怎样才能让这个变得可测试？我们需要以某种方式捕获输出。Rust 的标准库有一些处理 I/O（输入/输出）的简洁抽象，我们将使用一个<a href="https://doc.rust-lang.org/1.31.0/std/io/trait.Write.html"><code>std::io::Write</code></a>。这是一个<a href="https://doc.rust-lang.org/book/ch10-02-traits.html">trait</a>，它抽象了我们可以写(write)的东西，包括字符串,还有<code>stdout</code>。</p>
<p>如果这是接触 rust 后，你第一次听到“trait”（或特质，即行为接口），那你就要认真对待了。trait 是 Rust 最强大的功能之一。你可以把它们想象成 Java 中的接口，或者在 Haskell 中类型类（无论你熟悉什么）。它们允许您抽象不同类型可以共享的行为。使用 trait 的代码可用非常通用和灵活的方式表达思想。这意味着，它也很难（以正常人类的顺序）阅读。但不要让这种情况吓倒你：即使是多年来一直使用 rust 的人，也不总是能立即得到通用代码的行为。在这种情况下，它有助于思考具体的用途。例如，在我们的例子中，我们抽象的行为是“写它”。要实现（“impl”）这个类型的示例包括：终端的标准输出、文件、内存中的缓冲区或 TCP 网络连接。（向下滚动到<a href="https://doc.rust-lang.org/1.31.0/std/io/trait.Write.html">文件<code>std::io::Write</code></a>，查看“实现人员”名单。）</p>
<p>有了这些知识，让我们改变函数，接受第三个参数。而它应该是实现<code>Write</code>的。 这样，我们就可以在测试中，提供一个简单的字符串，并对其进行断言。以下是我们编写的这一版本的<code>find_matches</code>：</p>
<pre><code class="language-rust ignore">fn find_matches(content: &amp;str, pattern: &amp;str, mut writer: impl std::io::Write) {
    for line in content.lines() {
        if line.contains(pattern) {
            writeln!(writer, &quot;{}&quot;, line);
        }
    }
}
</code></pre>
<p>新参数是<code>mut writer</code>也就是说，我们称之为“writer”的可变(mut)事物。它的类型是<code>impl std::io::Write</code>，可以将理解为“实现<code>Write</code>trait”。还要注意我们如何将我们以前用的<code>println!(…)</code>，替换成<code>writeln!(writer, …)</code>。<code>println!</code>工作原理与<code>writeln!</code>相同，只是输出的对象总是标准输出。</p>
<p>现在，我们可以测试输出：</p>
<pre><code class="language-rust ignore">#[test]
fn find_a_match() {
    let mut result = Vec::new();
    find_matches(&quot;lorem ipsum\ndolor sit amet&quot;, &quot;lorem&quot;, &amp;mut result);
    assert_eq!(result, b&quot;lorem ipsum\n&quot;);
}
</code></pre>
<p>要在我们的应用程序代码中使用它，我们必须在<code>main</code>中，通过添加<a href="https://doc.rust-lang.org/1.31.0/std/io/fn.stdout.html"><code>&amp;mut std::io::stdout()</code></a>作为第三个参数，改成调用<code>find_matches</code>。下面是一个 main 函数的例子，它建立在我们在前几章中所看到的基础上，并使用我们提取的<code>find_matches</code>函数：</p>
<pre><code class="language-rust ignore">fn main() -&gt; Result&lt;(), ExitFailure&gt; {
    let args = Cli::from_args();
    let content = std::fs::read_to_string(&amp;args.path)
        .with_context(|_| format!(&quot;could not read file `{}`&quot;, args.path.display()))?;

    find_matches(&amp;content, &amp;args.pattern, &amp;mut std::io::stdout());

    Ok(())
}
</code></pre>
<aside class="note">
<p><strong>注：</strong> 因为<code>stdout</code>需要字节(byte)（不是字符串），我们使用<code>std::io::Write</code>而不是<code>std::fmt::Write</code>。 因此，在我们的测试中，我们把空向量赋给“writer”（其类型将推断为<code>Vec&lt;u8&gt;</code>），而在<code>assert_eq!</code>我们使用一个<code>b&quot;foo&quot;</code>。(<code>b</code>前缀使其成为<em>字节字符串文本</em>，以它的类型是<code>&amp;[u8]</code>，而不是<code>&amp;str</code>。）</p>
</aside>
<aside class="note">
<p><strong>注：</strong> 我们还可以使这个函数返回一个<code>String</code>，但这会改变它的行为。我们选择不再直接写入终端，而是将所有内容收集到一个字符串中，并在末尾一次性转储所有结果。</p>
</aside>
<aside class="exercise">
<p><strong>读者练习：</strong>
<a href="https://doc.rust-lang.org/1.31.0/std/macro.writeln.html"><code>writeln!</code></a>返回一个<a href="https://doc.rust-lang.org/1.31.0/std/io/type.Result.html"><code>io::Result</code></a>，因为写入可能会失败，例如当缓冲区已满且无法扩展时。向<code>find_matches</code>添加错误处理。</p>
</aside>
<p>我们刚刚看到了如何使这段代码变得容易测试。我们已经</p>
<ol>
<li>确定了我们应用程序的核心部分之一，</li>
<li>把它放在自己的函数里，</li>
<li>使其更加灵活。</li>
</ol>
<p>尽管我们的目标是让它成为可测试的，但最终得到的结果，实际上是一段非常惯用和可重用的 rust 代码。真好啊！</p>
<a class="header" href="#将代码拆分为库和二进制目标" id="将代码拆分为库和二进制目标"><h2>将代码拆分为库和二进制目标</h2></a>
<p>我们可以在这里再做一件事。到目前为止，我们已经把我们写的所有东西，都放在了<code>src/main.rs</code>文件。这意味着我们当前的项目，(构建)会生成一个二进制文件。但我们也可以将代码作为库提供，如下所示：</p>
<ol>
<li>把<code>find_matches</code>函数放到新的<code>src/lib.rs</code>。</li>
<li>添加一个<code>pub</code>在<code>fn</code>（也就是<code>pub fn find_matches</code>）使它成为用户可以访问的东西。</li>
<li>从<code>src/main.rs</code>中，去除<code>find_matches</code>。</li>
<li>在<code>fn main</code>，提前调用<code>grrs::</code>的<code>find_matches</code>，所以现在变为<code>grrs::find_matches(…)</code>. 这意味着它使用了我们刚刚编写的库中的函数！</li>
</ol>
<p>Rust 处理项目的方式是相当灵活的，尽早考虑将什么放入您的箱子的库中是一个好观念。例如，您可以考虑先为应用程序的特定逻辑编写一个库，然后像其他库一样在 CLI 中使用它。或者，如果您的项目有多个二进制文件，您可以将公共函数放在箱子的库部分。</p>
<aside class="note">
<p><strong>注：</strong> 说到如果我们继续，把所有的东西都堆到<code>src/main.rs</code>，它就会变得难以阅读。这个<a href="https://doc.rust-lang.org/1.31.0/book/ch07-00-packages-crates-and-modules.html">模块化系统</a>可以帮助您构造和组织代码。</p>
</aside>
<a class="header" href="#通过运行-cli-应用程序来测试它们" id="通过运行-cli-应用程序来测试它们"><h2>通过运行 CLI 应用程序来测试它们</h2></a>
<p>到目前为止，我们已经竭尽全力测试我们应用的<em>业务逻辑</em>，结果就是搞出了<code>find_matches</code>函数。这是非常有价值的，也是向经过良好测试的代码库，迈出的第一步。（通常，这类测试称为“单元测试”。）</p>
<p>但是，我们还有很多代码没有测试：我们为真实世界所编写的所有处理代码！假设您编写了 main 函数，但意外地留有一个硬编码字符串，而不是使用用户提供的路径参数。我们就应该为此编写测试！（这一级别的测试通常称为“集成测试”，或“系统测试”。）</p>
<p>在其核心，我们编写的(测试)函数还是用<code>#[test]</code>声明。重要的只是我们在这些函数中做什么的问题。例如，我们希望使用项目的 main 二进制文件，并像常规程序一样运行它。我们还将把这些测试，放入新目录中的新文件中：<code>tests/cli.rs</code>。</p>
<aside>
<p><strong>旁白：</strong> 按照惯例，<code>cargo</code>将在<code>tests/</code>目录中查找集成测试。同样，它也会看<code>benches/</code>中的基准测试和<code>examples</code>中的示例测试。这些(测试)约定还扩展到了您主要的源代码：比如库可以有一个<code>src/lib.rs</code>文件，main 二进制文件是<code>src/main.rs</code>或者，如果有多个二进制文件，则 cargo 希望它们位于<code>src/bin/&lt;name&gt;.rs</code>. 遵循这些约定将使阅读 rust 代码的人更明了您的代码库。</p>
</aside>
<p>回想起来，<code>grrs</code>是一个在文件中，搜索字符串的小工具。我们之前已经测试了匹配项的查找。让我们考虑一下，我们还可以测试哪些其他功能。</p>
<p>这是我想出来的。</p>
<ul>
<li>当文件不存在时，会发生什么？</li>
<li>当没有匹配项时，输出是什么？</li>
<li>当我们忘记一个（或两个）参数时，程序是否会出错退出？</li>
</ul>
<p>这些都是有效的测试用例。此外，我们还应该为“正确路径”包含一个测试用例，即我们找到至少一个匹配项，并打印出来。</p>
<p>为了使这些测试更简单，我们将使用<a href="https://docs.rs/assert_cmd"><code>assert_cmd</code></a>箱子。它有一堆整洁的助手，允许我们运行我们的主要二进制文件，并查看它的行为。此外，我们还将添加<a href="https://docs.rs/predicates"><code>predicates</code></a>箱子，有助于<code>assert_cmd</code>的断言测试（并且有很大的错误消息）。我们不会将这些依赖项，添加到依赖主列表，而是添加到我们的<code>Cargo.toml</code>中的”dev dependencies”(开发依赖)部分。只有在开发箱子时才需要它们，而不是在使用箱子时。</p>
<pre><code class="language-toml">[dev-dependencies]
assert_cmd = &quot;0.10&quot;
predicates = &quot;1&quot;
</code></pre>
<p>这听起来像是很多设置。不过，让我们直接上手，创建<code>tests/cli.rs</code>文件：</p>
<pre><code class="language-rust ignore">use std::process::Command;  // Run programs
use assert_cmd::prelude::*; // Add methods on commands
use predicates::prelude::*; // Used for writing assertions

#[test]
fn file_doesnt_exist() -&gt; Result&lt;(), Box&lt;std::error::Error&gt;&gt; {
    let mut cmd = Command::main_binary()?;
    cmd.arg(&quot;foobar&quot;)
        .arg(&quot;test/file/doesnt/exist&quot;);
    cmd.assert()
        .failure()
        .stderr(predicate::str::contains(&quot;No such file or directory&quot;));

    Ok(())
}
</code></pre>
<p>您可以使用<code>cargo test</code>运行此测试，命令只是我们上面写的测试。第一次可能需要更长的时间，比如<code>Command::main_binary()</code>需要编译你的主要二进制文件。</p>
<a class="header" href="#生成测试文件" id="生成测试文件"><h2>生成测试文件</h2></a>
<p>测试我们刚刚看到的只是检查我们程序写出的一个错误信息，表示输入文件不存在。
这是个要具备的重要测试，但可能不是最重要的那个。
让我们现在测试下，在文件中，实际找到的匹配项吧。</p>
<p>我们需要有一个文件，它的内容是我们知道的，这样我们才知道我们程序<em>应该</em>返回的正确匹配项，并在我们的测试中检查这个期望。一个想法是添加一个具有自定义内容的文件到项目，并在测试中使用。另一个则是在测试中创建临时文件。鉴于我们教程的情况，我们会搞下后者。具体来说，因为它更灵活，还可以用在其他案例；例如说，要测试一个改变文件的程序。</p>
<p>要创建这些个临时文件，我们会用到<a href="https://docs.rs/tempfile/3/tempfile/"><code>tempfile</code></a>箱子。让我们将它添加到<code>Cargo.toml</code>的<code>dev-dependencies</code>:</p>
<pre><code class="language-toml">tempfile = &quot;3&quot;
</code></pre>
<p>这是一个新的测试用例(，你可以在下面写另一个)，先创建一个临时文件(，命名它我们才能获得它的路径)，填充些文本，然后运行我们的程序，看看是不是正确输出。当<code>file</code> 走出作用域（函数的结尾），实际的临时文件会自动删除。</p>
<pre><code class="language-rust ignore">use tempfile::NamedTempFile;
use std::io::{self, Write};

#[test]
fn find_content_in_file() -&gt; Result&lt;(), Box&lt;std::error::Error&gt;&gt; {
    let mut file = NamedTempFile::new()?;
    writeln!(file, &quot;A test\nActual content\nMore content\nAnother test&quot;)?;

    let mut cmd = Command::main_binary()?;
    cmd.arg(&quot;test&quot;)
        .arg(file.path());
    cmd.assert()
        .success()
        .stdout(predicate::str::contains(&quot;test\nAnother test&quot;));

    Ok(())
}
</code></pre>
<aside class="exercise">
<p>**读者的练习:**添加一个集成测试，题目是传递一个空字符串作为匹配模式。调整程序通过测试。</p>
</aside>
<a class="header" href="#测试什么" id="测试什么"><h2>测试什么?</h2></a>
<p>尽管，编写集成测试确实有趣，还也是要花上不少时间，还要让测试持续跟上测试的变化。为了让你时间是花得更有意义，你应该三思下，你应该测试什么。</p>
<p>总的来说，一个的想法是，为所有用户注意到的行为类型，编写集成测试。
这意味着，你不需要覆盖所有的边缘情况。对于不同的类型，通常有一些例子就足够了，
还可以依靠单元测试来覆盖边缘情况。</p>
<p>最好不要把你的测试集中在你不能主动控制的事情上。
测试<code>--help</code>的确切布局是个坏主意，
因为它是为你生成/服务的。
相反，您可能只想检查某些元素是否存在。</p>
<p>根据你程序的本质，你可以尝试更多的测试技术。比如说，如果你已经提取了部分程序，并且想试着为(部分程序)所有的边缘情况，编写许多示例案例作为单元测试的话，那你应该看看<a href="https://docs.rs/proptest"><code>proptest</code></a>。又或是，你有一个消化任意文件并解析它们的程序，那就试着编写一个<a href="https://fuzz.rs/book/introduction.html">fuzzer</a>，在边缘发现 bug。</p>
<aside>
<p>**旁白:**你可以找到本章节，完整的、可运行的源代码，它<a href="https://github.com/rust-lang-nursery/cli-wg/tree/master/src/tutorial/testing">在这本书的库中</a>。</p>
</aside>
<a class="header" href="#打包和分发一个-rust-工具" id="打包和分发一个-rust-工具"><h1>打包和分发一个 Rust 工具</h1></a>
<p>如果你相信你的项目已经准备好了给人用了，那么是时候打包和发布了。</p>
<p>我们会有三种方法，并从”最快设置的“开始说明，直到”用户最方便的“。</p>
<a class="header" href="#最快的cargo-publish" id="最快的cargo-publish"><h2>最快的:<code>cargo publish</code></h2></a>
<p>发布您的应用程序的最简单方法就是用 Cargo。还记得如何在项目添加外部依赖吗？Cargo 会从箱子仓库<a href="https://crates.io/">crates.io</a>下载它们。通过<code>cargo publish</code>，你也可以轻松把箱子发布到<a href="https://crates.io/">crates.io</a>。对所有的箱子都适用，还包括那些二进制目标文件。</p>
<p>发布一个箱子到<a href="https://crates.io/">crates.io</a>很简单：如果你还没有试过，那要先在<a href="https://crates.io/">crates.io</a>创建一个账号。目前，可以通过 Github 账号授权完成，所以你会需要一个 Github 账号(并登陆)。下一步，通过在本地机器，使用 cargo 登陆，而要做到这一步，你要去到<a href="https://crates.io/me">crates.io 账户页面</a>创建一个新的令牌，然后运行<code>cargo login &lt;your-new-token&gt;</code>。每台电脑只需要做这一次。你可以在 cargo 的<a href="https://doc.rust-lang.org/1.31.0/cargo/reference/publishing.html">发布指南</a>上，了解更多。</p>
<p>现在，你知道了 cargo 还有 crates.io。那你就准备好发布箱子了。在你匆忙发布一个新箱子之前，请确保你为你的箱子，添加了必要的元信息。你可以在<a href="https://doc.rust-lang.org/1.31.0/cargo/reference/manifest.html">Cargo 的清单格式</a>上，找到所有你能设置的字段。下面有个常用字段的快速预览。</p>
<pre><code class="language-toml">[package]
name = &quot;grrs&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;your@email.com&gt;&quot;]
license = &quot;MIT OR Apache-2.0&quot;
description = &quot;A tool to search files&quot;
readme = &quot;README.md&quot;
homepage = &quot;https://github.com/you/grrs&quot;
repository = &quot;https://github.com/you/grrs&quot;
keywords = [&quot;cli&quot;, &quot;search&quot;, &quot;demo&quot;]
categories = [&quot;command-line-utilities&quot;]
</code></pre>
<aside class="note">
<p><strong>注：</strong> 这个例子包括强制的许可证字段，是给 Rust 项目的常见选择：该许可证还用于 Rust 编译器本身。它还指向一个<code>README.md</code>文件。它应该包括对您的项目是关于什么的一个快速描述，并且不仅会在您箱子的 crates.io 页面上，而且还包括 Github 默认情况下在存储库页面上显示的。</p>
</aside>
<a class="header" href="#如何从-cratesio-安装二进制文件" id="如何从-cratesio-安装二进制文件"><h3>如何从 crates.io 安装二进制文件</h3></a>
<p>我们已经看到了如何将箱子发布到 crates.io，您可能想知道如何安装它。与库不同的是，当你运行<code>cargo build</code>（或类似的命令）的时候， Cargo 会为你下载和编译哪些，您需要显式告诉它安装二进制文件。</p>
<p>这是用<code>cargo install &lt;crate-name&gt;</code>完成的。 默认情况下，它将下载箱子，编译它包含的所有二进制目标文件（“发布”模式，因此可能需要一段时间），并将它们复制到<code>~/.cargo/bin/</code>目录。（确保您的 shell ，知道在那里查找二进制文件！）</p>
<p>也可以从 Git 存储库安装箱子，只安装一个箱子的特定二进制文件，并指定一个备选目录来安装它们。查看<code>cargo install --help</code>有关详细信息。</p>
<a class="header" href="#何时使用" id="何时使用"><h3>何时使用</h3></a>
<p><code>cargo install</code>是发布二进制箱子的简单方法。Rust 开发人员使用起来非常方便，但也有一些明显的缺点：因为它总是从头开始编译源代码，所以您的工具的用户将需要拥有 Rust、Cargo 以及您的项目需要的所有其他系统依赖项，都要安装在用户机器上。编写大型 Rust 代码库也需要一些时间。</p>
<p>此外，没有简单的方法来更新用 cargo 安装的工具：用户需要在某个时刻运行<code>cargo install</code>，并通过<code>--force</code>覆盖旧二进制文件的标志。这是一个<a href="https://github.com/rust-lang/cargo/issues/2082">missing 功能</a>，不过还有<a href="https://crates.io/crates/cargo-update">像这个一样</a>子命令，您可以通过安装来添加它。</p>
<p>最好将其用于分发，针对其他 Rust 开发人员的工具。例如：有很多 Cargo 的子命令 <code>cargo-tree</code>或<code>cargo-outdated</code>，可以和它一起安装。</p>
<a class="header" href="#分发二进制文件" id="分发二进制文件"><h2>分发二进制文件</h2></a>
<p>Rust 是一种编译为本机代码的语言，默认情况下静态链接所有依赖项。当你在<code>grrs</code>项目中运行<code>cargo build</code>，那么它会(构建)一个<code>grrs</code>二进制文件。尝试一下：使用<code>cargo build</code>，构建在<code>target/debug/grrs</code>。而当你运行<code>cargo build --release</code>，则会构建在<code>target/release/grrs</code>。除非使用显式需要在目标系统上，安装外部库的箱子（如使用系统的 OpenSSL 版本），否则此二进制文件将仅依赖于公共系统库。这就是说，你只需要把一个文件，发送给和你运行相同操作系统的人，他们就可以运行它了。</p>
<p>这已经很强大了！它可以解决我们刚才在<code>cargo install</code>上看到的两个缺点：不需要在用户的机器上安装 Rust，他们可以立即运行二进制文件，而不需要花一分钟来编译。</p>
<p>所以，正如我们所看到的，<code>cargo build</code> <em>已经</em>为我们构建二进制文件。唯一的问题是，它们不能保证在所有平台上都能工作。如果<code>cargo build</code>在您的 Windows 机器上，默认情况下，就不会得到在 Mac 上工作的二进制文件。有没有一种方法，可以为所有感兴趣的平台自动生成这些二进制文件？</p>
<a class="header" href="#在-ci-上构建二进制发布" id="在-ci-上构建二进制发布"><h3>在 CI 上构建二进制发布</h3></a>
<p>如果您的工具是开源的，并且托管在 GitHub 上，那么很容易建立一个免费的 CI（持续集成）服务，比如<a href="https://travis-ci.com/">Travis CI</a>。（还有其他服务也可以在其他平台上工作，但 Travis 非常流行。）这基本上是，在每次将更改推送到存储库时，就在虚拟机中，运行所设置命令。这些命令是什么，以及它们运行的机器类型都是可配置的。例如：一个好主意是在机器上运行<code>cargo test</code>，配有 Rust 和一些常用的工具。如果失败，您就知道最近的更改中存在问题。</p>
<p>我们还可以使用它，来构建二进制文件，并将它们上载到 Github！事实上，如果我们运行<code>cargo build --release</code>，并把二进制文件上传到某个地方，那么我们应该都设置好了，对吗？不完全是。我们仍然需要确保我们构建的二进制文件，与尽可能多的系统兼容。例如，在 Linux 上，我们可以不设为当前系统编译，而是为<code>x86_64-unknown-linux-musl</code>目标，不依赖默认系统库。在 MacOS 上，我们可以设置<code>MACOSX_DEPLOYMENT_TARGET</code>到<code>10.7</code>，仅依赖于 10.7 及更高版本中的系统功能。</p>
<p>您可以看到使用这种方法构建二进制文件的一个示例，<a href="https://github.com/rustwasm/wasm-pack/blob/51e6351c28fbd40745719e6d4a7bf26dadd30c85/.travis.yml#L74-L91">这是</a>针对 Linux 和 MacOS ，以及<a href="https://github.com/rustwasm/wasm-pack/blob/51e6351c28fbd40745719e6d4a7bf26dadd30c85/.appveyor.yml">这是</a>针对 Windows（使用 AppVeyor）。</p>
<p>另一种方法是使用预构建（Docker）映像，其中包含构建二进制文件所需的所有工具。这也使我们能够轻松瞄准，更具异国情调的平台。这个<a href="https://github.com/japaric/trust">trust</a>Project 包含的脚本，可以 include 你的项目，以及有关如何设置的说明。它还包括对使用 AppVeyor 的 Windows 的支持。</p>
<p>如果您希望在本地设置它，并在您的计算机上生成发布文件，那么您仍然可以查看 trust。它在内部使用<a href="https://github.com/rust-embedded/cross">cross</a>，它的工作原理类似于 Cargo，但将命令转发给 Docker 容器内的 Cargo 处理。镜像的定义也在<a href="https://github.com/rust-embedded/cross">cross 的存储库</a>可用。</p>
<a class="header" href="#如何安装这些二进制文件" id="如何安装这些二进制文件"><h3>如何安装这些二进制文件</h3></a>
<p>你把你的用户指向你的发布页面，<a href="https://github.com/rustwasm/wasm-pack/releases/tag/v0.5.1">像这个一样</a>。他们就可以下载我们刚刚创建的工件。我们刚刚生成的发布工件，没有什么特别的：最后，它们只是包含我们的二进制文件的存档文件！这意味着，工具的用户可以用浏览器下载它们，提取它们（通常是自动执行的），并将二进制文件复制到他们喜欢的地方。</p>
<p>这确实需要一些手动“安装”程序的经验，因此您需要在 REAMDE 文件中，添加有关如何安装此程序的部分。</p>
<aside class="note">
<p><strong>注：</strong> 如果你用<a href="https://github.com/japaric/trust">trust</a>构建二进制文件，并将其添加到 GitHub 版本中，还可以告诉人们运行<code>curl -LSfs https://japaric.github.io/trust/install.sh | sh -s -- --git your-name/repo-name</code>，如果你认为这样更容易的话。</p>
</aside>
<a class="header" href="#何时使用-1" id="何时使用-1"><h3>何时使用</h3></a>
<p>一般来说，使用二进制发布是一个好主意，几乎没有任何缺点。当然，它不能解决用户必须手动安装，和更新您的工具的问题，但他们可以快速获得最新版本，而无需安装 rust。</p>
<a class="header" href="#除了二进制文件外还要打包什么" id="除了二进制文件外还要打包什么"><h3>除了二进制文件外，还要打包什么</h3></a>
<p>现在，当用户下载我们的发布版本时，他们将获得<code>.tar.gz</code>，一个只包含二进制文件的(压缩)文件。所以，在我们的示例项目中，他们只会得到一个他们可以运行的<code>grrs</code>文件。但我们的存储库中，已经有了一些他们可能想要的更多文件。如：告诉他们如何使用这个工具的 REAMDE 文件，还有许可证文件。因为我们已经有了它们，所以它们很容易添加。</p>
<p>不过，还有一些更有趣的文件，特别是对于命令行工具来说更为合理：除了这个 REAMDE 文件之外，我们还提供了一个手册，以及向 shell 添加补全可能标志的配置文件如何？你可以用手写，但是<em>鼓掌吧(clap)</em>，我们的参数解析库（也是 structopt 的基础库）有一种为我们生成所有这些文件的方法。见<a href="../in-depth/docs.zh.html">深入的章节</a>，了解更多详细信息。</p>
<a class="header" href="#将应用程序放入软件包存储库" id="将应用程序放入软件包存储库"><h2>将应用程序放入软件包存储库</h2></a>
<p>到目前为止，我们看到的两种方法，都不是您常在计算机上安装软件的方法。尤其是在大多数操作系统上，会使用全局包管理器安装命令行工具。用户的优势是显而易见的：如果可以像安装其他工具一样安装程序，就不必考虑如何安装程序。这些，包管理器还允许用户在新版本可用时，更新其程序。</p>
<p>不幸的是，支持不同的系统意味着，你必须看看这些不同的系统是如何工作的。对于某某来说，这可能跟往存储库内，添加文件一样简单（例如，添加一个 Formula 文件，如给 MacOS<code>brew</code>使用的<a href="https://github.com/BurntSushi/ripgrep/blob/31adff6f3c4bfefc9e77df40871f2989443e6827/pkg/brew/ripgrep-bin.rb">这个</a>文件），但对于其他的，您通常需要自己发送补丁，并将您的工具，添加到他们的存储库中。有一些有用的工具，比如<a href="https://crates.io/crates/cargo-rpm">cargo-rpm</a>和<a href="https://crates.io/crates/cargo-deb">cargo-deb</a>。但是，描述它们是如何工作的，以及如何为这些不同的系统，正确地打包您的工具超出了本章的范围。</p>
<p>相反，让我们来看一个用 Rust 编写的工具，它可以在许多不同的包管理器中使用。</p>
<a class="header" href="#例如ripgrep" id="例如ripgrep"><h3>例如：ripgrep</h3></a>
<p><a href="https://github.com/BurntSushi/ripgrep">ripgrep</a>是用 Rust 编写的<code>grep</code>/<code>ack</code>/<code>ag</code>替代。它非常成功，适用于许多操作系统：请看它 REAMDE 文件的<a href="https://github.com/BurntSushi/ripgrep/tree/31adff6f3c4bfefc9e77df40871f2989443e6827#installation">“安装”部分</a>！</p>
<p>请注意，它列出了几个不同的选项，如何去安装它：它从一个指向包含二进制文件的 GitHub 发行版的链接开始，这样您就可以直接下载它们；然后它列出了，如何使用一组不同的包管理器安装它；最后，您还可以使用<code>cargo install</code>。</p>
<p>这似乎是一个很好的主意：不去选择这里介绍的方法，而是从<code>cargo install</code>开始，加上二进制版本，最后开始使用(各个)系统包管理器，来分发工具。</p>
<a class="header" href="#深入的主题" id="深入的主题"><h1>深入的主题</h1></a>
<a class="header" href="#信号处理" id="信号处理"><h1>信号处理</h1></a>
<p>像命令行应用程序这样的进程，需要对操作系统发送的信号作出反应。最常见的例子可能是<kbd>Ctrl </kbd>+<kbd>C</kbd>，通常指示进程终止的信号。要在 Rust 程序中处理信号，您需要考虑如何接收这些信号，以及如何对它们作出反应。</p>
<aside>
<p><strong>注：</strong> 如果您的应用程序不需要正常关闭，则默认处理就可以了（即立即退出，并让操作系统清理资源，如打开的文件控制）。在这种情况下：不需要做本章告诉你的事情！</p>
<p>但是，对于需要自己清理的应用程序，本章非常有关系！例如，如果应用程序需要正确关闭网络连接（与另一端的进程说再见），删除临时文件，或重置系统设置，那就继续阅读吧。</p>
</aside>
<a class="header" href="#操作系统之间的差异" id="操作系统之间的差异"><h2>操作系统之间的差异</h2></a>
<p>在 UNIX 系统（如 Linux、MacOS 和 FreeBSD）上，一个进程可以接收<a href="https://manpages.ubuntu.com/manpages/bionic/en/man7/signal.7.html">信号</a>。可以以默认（操作系统提供的）方式对信号作出反应，捕获信号并以程序定义的方式处理它们，或者完全忽略信号。</p>
<p>Windows 没有信号。你可以用<a href="https://docs.microsoft.com/de-de/windows/console/console-control-handlers">控制台处理程序</a>定义在事件发生时，执行的回调。还有<a href="https://docs.microsoft.com/en-us/windows/desktop/debug/structured-exception-handling">结构化异常处理</a>，它处理所有类型的系统异常，如除数为零、无效访问异常、堆栈溢出等。</p>
<a class="header" href="#第一步处理-ctrlc" id="第一步处理-ctrlc"><h2>第一步：处理 ctrl+c</h2></a>
<p>这个<a href="https://crates.io/crates/ctrlc">ctrlc</a>箱子所做的，正是它的名字所暗示的：它允许你对用户按下<kbd>Ctrl </kbd>+<kbd>C</kbd>，以跨平台的方式。使用箱子的主要方法是：</p>
<pre><code class="language-rust ignore">fn main() {
    ctrlc::set_handler(move || {
        println!(&quot;received Ctrl+C!&quot;);
    }).expect(&quot;Error setting Ctrl-C handler&quot;);

    // ...
}
</code></pre>
<p>当然，这并没有那么有帮助：它只打印一条消息，并且不会停止程序。</p>
<p>在一个真实的程序中，最好在信号处理程序中，设置一个变量，然后在程序中的各个地方进行检查。例如，可以在信号处理程序中设置<code>Arc&lt;AtomicBool&gt;</code>（线程之间可共享的布尔值），在热循环中，或者在等待线程时，您会定期检查其值，并在该值变为真时，中断。</p>
<a class="header" href="#处理其他类型的信号" id="处理其他类型的信号"><h2>处理其他类型的信号</h2></a>
<p>这个<a href="https://crates.io/crates/ctrlc">ctrlc</a>箱子仅处理<kbd>Ctrl </kbd>+<kbd>C</kbd>或者，在 UNIX 系统上称为<code>SIGINT</code>（中断信号）。要对更多的 Unix 信号，作出反应，您应该看看<a href="https://crates.io/crates/signal-hook">信号钩子</a>。 其设计在<a href="https://vorner.github.io/2018/06/28/signal-hook.html">这篇博客文章</a>上有所描述，并且这是目前社区支持最广泛的库了。</p>
<p>下面是一个简单的例子：</p>
<pre><code class="language-rust ignore">use std::{error::Error, thread};
use signal_hook::{iterator::Signals, SIGINT};

fn main() -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    let signals = Signals::new(&amp;[SIGINT])?;

    thread::spawn(move || {
        for sig in signals.forever() {
            println!(&quot;Received signal {:?}&quot;, sig);
        }
    });

    Ok(())
}
</code></pre>
<a class="header" href="#使用通道" id="使用通道"><h2>使用通道</h2></a>
<p>您可以使用通道，而不是设置一个变量并让程序的其他部分检查它：您创建一个通道，每当接收到信号时，信号处理程序就向该通道发送一个值。在应用程序代码中，您可以使用此通道与其他通道的联系，作为线程之间的同步桥梁。使用<a href="https://crates.io/crates/crossbeam-channel">crossbeam-channel</a>箱子，它看起来像这样：</p>
<pre><code class="language-rust ignore">use std::time::Duration;
use crossbeam_channel::{bounded, tick, Receiver, select};

fn ctrl_channel() -&gt; Result&lt;Receiver&lt;()&gt;, ctrlc::Error&gt; {
    let (sender, receiver) = bounded(100);
    ctrlc::set_handler(move || {
        let _ = sender.send(());
    })?;

    Ok(receiver)
}

fn main() -&gt; Result&lt;(), exitfailure::ExitFailure&gt; {
    let ctrl_c_events = ctrl_channel()?;
    let ticks = tick(Duration::from_secs(1));

    loop {
        select! {
            recv(ticks) -&gt; _ =&gt; {
                println!(&quot;working!&quot;);
            }
            recv(ctrl_c_events) -&gt; _ =&gt; {
                println!();
                println!(&quot;Goodbye!&quot;);
                break;
            }
        }
    }

    Ok(())
}
</code></pre>
<a class="header" href="#使用-future-和-stream" id="使用-future-和-stream"><h2>使用 future 和 stream</h2></a>
<p>如果您正在使用<a href="https://tokio.rs/">tokio</a>，您很可能已经用异步模式和事件驱动设计，编写了应用程序。您可以启用信号钩子的<code>tokio-support</code>功能，而不是直接使用 crossbeam 的 channels。这可以让你在信号钩子的<code>Signals</code>类型上，调用<a href="https://docs.rs/signal-hook/0.1.6/signal_hook/iterator/struct.Signals.html#method.into_async"><code>.into_async()</code></a>，以获取实现了<code>futures::Stream</code>的新类型。</p>
<a class="header" href="#当您在处理第一个-ctrlc-时收到另一个-ctrlc-时要做什么" id="当您在处理第一个-ctrlc-时收到另一个-ctrlc-时要做什么"><h2>当您在处理第一个 ctrl+c 时，收到另一个 ctrl+c 时要做什么？</h2></a>
<p>大多数用户会按<kbd>Ctrl </kbd>+<kbd>C</kbd>，然后给你的程序几秒钟退出，或者告诉他们发生了什么。如果那不发生，他们再一次按<kbd>Ctrl </kbd>+<kbd>C</kbd>。典型的处理行为是让应用程序立即退出。</p>
<a class="header" href="#使用配置文件" id="使用配置文件"><h1>使用配置文件</h1></a>
<p>处理配置可能很烦人，特别是如果您支持多个操作系统，这些操作系统都有自己存放临时和长期文件的位置。</p>
<p>对此有多种解决方案，其中一些方案的级别较低。</p>
<p>最容易使用的箱子是<code>confy</code>. 它要求您输入应用程序的名称，并要求您通过<code>struct</code>指定配置层级（那是<code>Serialize</code>序列化，<code>Deserialize</code>反序列化），剩下的交给它解决了！</p>
<pre><code class="language-rust ignore">#[derive(Debug, Serialize, Deserialize)]
struct MyConfig {
    name: String,
    comfy: bool,
    foo: i64,
}

fn main() -&gt; Result&lt;(), io::Error&gt; {
    let cfg: ConfyConfig = confy::load(&quot;my_app&quot;)?;
    println!(&quot;{:#?}&quot;, cfg);
    Ok(())
}
</code></pre>
<p>如果你会放弃可配置性，这当然是非常容易使用的。而如果你确实就要一个简单的配置，这个箱子就是为你准备！</p>
<a class="header" href="#配置环境" id="配置环境"><h2>配置环境</h2></a>
<aside class="todo">
<p><strong>TODO</strong></p>
<ol>
<li>评估存在的箱子</li>
<li>cli 参数 + 多个 configs + env 变量</li>
<li><code>configure</code>都能做？有好的 Rust 包装吗？</li>
</ol>
</aside>
<a class="header" href="#退出代码" id="退出代码"><h1>退出代码</h1></a>
<p>程序并不总是成功的。当发生错误时，您应该确保正确地发出必要的信息。除了在大多数系统上<a href="human-communication.zh.html">告诉用户错误</a>，当进程退出时，它也会发出退出代码（0 到 255 之间的整数，与大多数平台兼容）。您应该尝试为程序的状态发出正确的代码。例如，在理想情况下，当程序成功时，它应该的退出代码为<code>0</code>。</p>
<p>但是，当一个错误发生时，它会变得更加复杂。在真实世界，许多工具(的退出代码)会是<code>1</code>当发生常见故障时。目前当进程恐慌时，Rust 设置的退出代码为<code>101</code>。除此之外，人们在他们的程序中，还做了很多事情。</p>
<p>那么，该怎么办？BSD 生态系统收集了它们退出代码的通用定义（您可以<a href="https://www.freebsd.org/cgi/man.cgi?query=sysexits&amp;apropos=0&amp;sektion=0&amp;manpath=FreeBSD+11.2-stable&amp;arch=default&amp;format=html">在这里</a>找到它们）。Rust 箱子<a href="https://crates.io/crates/exitcode"><code>exitcode</code></a>提供这些相同的代码，可以在应用程序中使用。有关可能使用的值，请参阅其 API 文档。</p>
<p>一种使用方法是这样的：</p>
<pre><code class="language-rust ignore">fn main() {
    // ...actual work...
    match result {
        Ok(_) =&gt; {
            println!(&quot;Done!&quot;);
            std::process::exit(exitcode::OK);
        }
        Err(CustomError::CantReadConfig(e)) =&gt; {
            eprintln!(&quot;Error: {}&quot;, e);
            std::process::exit(exitcode::CONFIG);
        }
        Err(e) =&gt; {
            eprintln!(&quot;Error: {}&quot;, e);
            std::process::exit(exitcode::DATAERR);
        }
    }
}
</code></pre>
<a class="header" href="#与人交流" id="与人交流"><h1>与人交流</h1></a>
<p>确保先在教程中，阅读<a href="../tutorial/output.zh.html">关于 CLI 输出的章节</a>。它包括如何将输出写入终端，而本章将讨论<em>什么</em>是输出。</p>
<a class="header" href="#当一切都好的时候" id="当一切都好的时候"><h2>当一切都好的时候</h2></a>
<p>即使一切正常，报告应用程序的进度也很有用。在这些信息中，尽量做到大众性和简洁性。不要在日志中，使用过多的技术术语。记住这一准则：应用程序没有崩溃，那么，用户就没有理由查找错误。</p>
<p>最重要的是，保持交流风格的一致性。使用相同的前缀和句式结构，使日志易于浏览。</p>
<p>尝试让应用程序的输出，讲述它正在做什么，以及它如何影响用户。这可能涉及到，显示所涉及步骤的时间线，甚至是长期运行操作的进度条和指示器。用户在任何时候，都不应该感觉到应用程序，在做一些他们无法理解的神秘事情。</p>
<a class="header" href="#当很难知道发生了什么事时" id="当很难知道发生了什么事时"><h2>当很难知道发生了什么事时</h2></a>
<p>当交流不可名状时，保持一致是很重要的。不遵循严格日志记录级别的，且要大量日志记录的应用程序，所提供的信息量，与非日志记录应用程序的相同，甚至更少。</p>
<p>因此，重要的是，定义与之相关的事件和消息的严重性，然后对它们使用一致的日志级别。这样用户就可以通过<code>--verbose</code>标志或环境变量（如<code>RUST_LOG</code>）选择哪堆日志。</p>
<p>常用<code>log</code>箱子<a href="https://docs.rs/log/0.4.4/log/enum.Level.html">定义</a>的以下级别（按严重性，增序）：</p>
<ul>
<li>trace</li>
<li>debug</li>
<li>info</li>
<li>warning</li>
<li>error</li>
</ul>
<p>好主意是，把 <em>info</em>作为默认日志级别。信息的输出。（一些倾向于更安静输出样式的应用程序，在默认情况下，可能只显示警告和错误。）</p>
<p>此外，在日志消息中，使用类似的前缀和句式结构总是好的，这样，就可以使用类似<code>grep</code>来过滤它们。消息本身应该提供足够的上下文，以便在筛选日志中有用，但同时不要<em>太</em>冗长。</p>
<a class="header" href="#日志语句示例" id="日志语句示例"><h3>日志语句示例</h3></a>
<pre><code class="language-console">error: could not find `Cargo.toml` in `/home/you/project/`
</code></pre>
<pre><code class="language-console">=&gt; Downloading repository index
=&gt; Downloading packages...
</code></pre>
<p>以下日志输出来自 <a href="https://crates.io/crates/wasm-pack">wasm-pack</a>：</p>
<pre><code class="language-console"> [1/7] Adding WASM target...
 [2/7] Compiling to WASM...
 [3/7] Creating a pkg directory...
 [4/7] Writing a package.json...
 &gt; [WARN]: Field `description` is missing from Cargo.toml. It is not necessary, but recommended
 &gt; [WARN]: Field `repository` is missing from Cargo.toml. It is not necessary, but recommended
 &gt; [WARN]: Field `license` is missing from Cargo.toml. It is not necessary, but recommended
 [5/7] Copying over your README...
 &gt; [WARN]: origin crate has no README
 [6/7] Installing WASM-bindgen...
 &gt; [INFO]: wasm-bindgen already installed
 [7/7] Running WASM-bindgen...
 Done in 1 second
</code></pre>
<a class="header" href="#当恐慌时" id="当恐慌时"><h2>当恐慌时</h2></a>
<p>一个经常被遗忘的方面是，当程序崩溃时，它也会输出一些东西。在 Rust 中，“崩溃”通常是“恐慌(panic)”（即，“崩溃控制”，与“操作系统杀死了进程”有所不同）。默认情况下，当发生紧急情况时，“崩溃处理程序”将向控制台打印一些信息。</p>
<p>例如，如果使用<code>cargo new --bin foo</code>创建一个新的二进制项目，并用<code>panic!(&quot;Hello World&quot;)</code>替代<code>fn main</code>中的内容，运行程序时会得到：</p>
<pre><code class="language-console">thread 'main' panicked at 'Hello, world!', src/main.rs:2:5
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>这对你和开发者来说，都是有用的信息。（意外：程序因您的<code>main.rs</code>文件的第2行而崩溃）。但是对于一个，甚至不访问源代码的用户来说，这并不是很有价值。事实上，它很可能只是令人困惑。这就是为什么添加一个定制的崩溃处理程序是一个好的主意，它提供了一个更加注重最终用户的输出。</p>
<p>有一个箱子就是这么做的，它叫做<a href="https://crates.io/crates/human-panic">human-panic</a>。要将其添加到 CLI 项目中，请导入它，并在<code>main</code>函数种调用<code>setup_panic!()</code>宏：</p>
<pre><code class="language-rust ignore">use human_panic::setup_panic;

fn main() {
   setup_panic!();

   panic!(&quot;Hello world&quot;)
}
</code></pre>
<p>这将显示一条非常友好的消息，并告诉用户他们可以做什么：</p>
<pre><code class="language-console">Well, this is embarrassing.

foo had a problem and crashed. To help us diagnose the problem you can send us a crash report.

We have generated a report file at &quot;/var/folders/n3/dkk459k908lcmkzwcmq0tcv00000gn/T/report-738e1bec-5585-47a4-8158-f1f7227f0168.toml&quot;. Submit an issue or email with the subject of &quot;foo Crash Report&quot; and include the report as an attachment.

- Authors: Your Name &lt;your.name@example.com&gt;

We take privacy seriously, and do not perform any automated error collection. In order to improve the software, we rely on people to submit reports.

Thank you kindly!
</code></pre>
<a class="header" href="#与机器交互" id="与机器交互"><h1>与机器交互</h1></a>
<p>当您能够组合命令行工具时，它们的威力真的会很闪耀。这不是一个新想法：事实上，这是<a href="https://en.wikipedia.org/wiki/Unix_philosophy">Unix 哲学</a>：</p>
<blockquote>
<p>期望每个程序的输出，都成为另一个程序的输入，这正是你无法想像的程序。</p>
</blockquote>
<p>如果我们的程序满足这个期望，我们的用户会很高兴。为了确保这项工作良好，我们不仅应该为人类提供相当好的输出，还应该为其他程序提供一个适合的版本。让我们看看怎么做。</p>
<aside>
<p><strong>旁白：</strong> 确保先阅读在教程中的<a href="../tutorial/output.zh.html">关于 CLI 输出的章节</a>。它包括如何将输出写入终端。</p>
</aside>
<a class="header" href="#谁在读取" id="谁在读取"><h2>谁在读取？</h2></a>
<p>要问的第一个问题是：我们的输出是给彩色终端前的人类，还是给另一个程序？为了回答这个问题，我们可以使用像<a href="https://crates.io/crates/atty">atty</a>这样的箱子：</p>
<pre><code class="language-rust ignore">use atty::Stream;

if atty::is(Stream::Stdout) {
    println!(&quot;I'm a terminal&quot;);
} else {
    println!(&quot;I'm not&quot;);
}
</code></pre>
<p>根据谁读取我们的输出，我们之后就可以添加额外的信息。人类喜欢颜色，例如，如果你在一个随机的 Rust 项目中运行<code>ls</code>，您可能会看到这样的情况：</p>
<pre><code class="language-console">$ ls
CODE_OF_CONDUCT.md   LICENSE-APACHE       examples
CONTRIBUTING.md      LICENSE-MIT          proptest-regressions
Cargo.lock           README.md            src
Cargo.toml           convey_derive        target
</code></pre>
<p>因为这种样式是为人类设计的，在大多数配置中，它甚至会打印一些名称（例如<code>src</code>），并以彩色显示它们是目录。如果您改为将这个输出，经过管道传输到文件或类似<code>cat</code>的程序，<code>ls</code>会调整其输出。它将在单行上，打印每个条目，而不是使用适合我的终端窗口的列数。它也不会发出任何颜色。</p>
<pre><code class="language-console">$ ls | cat
CODE_OF_CONDUCT.md
CONTRIBUTING.md
Cargo.lock
Cargo.toml
LICENSE-APACHE
LICENSE-MIT
README.md
convey_derive
examples
proptest-regressions
src
target
</code></pre>
<a class="header" href="#机器的简单输出格式" id="机器的简单输出格式"><h2>机器的简单输出格式</h2></a>
<p>历史上，命令行工具生成输出的唯一类型，就是字符串。对于那些在终端前，能够阅读文本和理解其含义的人来说，这通常是很好的。但是，其他程序通常没有这种能力：它们理解类似<code>ls</code>工具输出的唯一方法，就在于程序的作者是否包含一个<code>ls</code>输出的解析器。</p>
<p>这通常意味着，输出仅限于易于解析的内容。像 TSV（Tab 分隔值）这样的格式非常流行，其中每个记录都在自己的行上，并且每一行包含 tab 分隔的内容。这些基于文本行的简单格式，允许<code>grep</code>能用在像<code>ls</code>这样会输出的工具上。<code>| grep Cargo</code>才不管你的文本是不是来自<code>ls</code>或者文件，它都会逐行过滤。</p>
<p>缺点是你不能用简单调用<code>grep</code>，就筛选<code>ls</code>给你的所有目录。因为，每个目录项，都需要携带额外的数据。</p>
<a class="header" href="#机器的-json-输出" id="机器的-json-输出"><h2>机器的 JSON 输出</h2></a>
<p>tab 分隔值是输出结构化数据的一种简单方法，但它要求另一个程序知道要预想哪个字段（以及顺序），并且很难输出不同类型的消息。例如，假设我们的程序，想向用户发送消息，告诉他们，它当前正在等待下载，然后输出一条消息，描述它得到的数据。这些都可能是非常不同的类型的消息，试图在 TSV 输出中统一它们，需要我们发明一种方法来区分它们。同样的情况还有，当我们想要打印包含两个不同长度项的列表的消息时。</p>
<p>不过，最好选择一种在大多数编程语言/环境中，都易于解析的格式。因此，在过去的几年中，许多应用程序都发展<a href="https://www.json.org/">JSON</a>的解析能力。JSON 很简单，几乎每种语言都存在它的解析器，但其强大程度，足以在许多情况下发挥作用。虽然它是一种人类可以读取的文本格式，但许多人也在，解析 JSON 数据，和将数据序列化为 JSON 方面做了许多工作，现已是速度非常快的实现了。</p>
<p>在上面的描述中，我们已经讨论过程序要编写“消息”。这是一种考虑输出的好方法：其实程序不一定只输出一个数据块，而实际上，在运行的时候可能会发出许多不同(类型)的信息。在输出 JSON 时，支持这种方法的一个简单方法，是为每条消息编写一个 JSON 文档，并将每个 JSON 文档放到新的一行（有时，调用下<a href="https://en.wikipedia.org/wiki/JSON_streaming#Line-delimited_JSON">行-分隔 JSON</a>）。这可以让(信息)实现像使用常规的<code>println!</code>一样简单。</p>
<p>下面是一个简单的例子，使用来自<a href="https://crates.io/crates/serde_json">serde_json</a>的<code>json!</code>宏，用来在您的 Rust 源代码中，快速编写有效的 JSON：</p>
<pre><code class="language-rust ignore">use structopt::StructOpt;
use serde_json::json;

/// Search for a pattern in a file and display the lines that contain it.
#[derive(StructOpt)]
struct Cli {
    /// Output JSON instead of human readable messages
    #[structopt(long = &quot;json&quot;)]
    json: bool,
}

fn main() {
    let args = Cli::from_args();
    if args.json {
        println!(&quot;{}&quot;, json!({
            &quot;type&quot;: &quot;message&quot;,
            &quot;content&quot;: &quot;Hello world&quot;,
        }));
    } else {
        println!(&quot;Hello world&quot;);
    }
}
</code></pre>
<p>下面是输出：</p>
<pre><code class="language-console">$ cargo run -q
Hello world
$ cargo run -q -- --json
{&quot;content&quot;:&quot;Hello world&quot;,&quot;type&quot;:&quot;message&quot;}
</code></pre>
<p>（运行<code>cargo</code>带<code>-q</code>，能抑制其正常输出。<code>--</code>后面的参数被传递到我们的程序。）</p>
<a class="header" href="#实例ripgrep" id="实例ripgrep"><h3>实例：ripgrep</h3></a>
<p>*<a href="https://github.com/BurntSushi/ripgrep">ripgrep</a>*是 <em>grep</em> 或 <em>ag</em> 的替代品，用 Rust 写的。默认情况下，它将生成如下输出：</p>
<pre><code class="language-console">$ rg default
src/lib.rs
37:    Output::default()

src/components/span.rs
6:    Span::default()
</code></pre>
<p>但是给出<code>--json</code>，它将打印：</p>
<pre><code class="language-console">$ rg default --json
{&quot;type&quot;:&quot;begin&quot;,&quot;data&quot;:{&quot;path&quot;:{&quot;text&quot;:&quot;src/lib.rs&quot;}}}
{&quot;type&quot;:&quot;match&quot;,&quot;data&quot;:{&quot;path&quot;:{&quot;text&quot;:&quot;src/lib.rs&quot;},&quot;lines&quot;:{&quot;text&quot;:&quot;    Output::default()\n&quot;},&quot;line_number&quot;:37,&quot;absolute_offset&quot;:761,&quot;submatches&quot;:[{&quot;match&quot;:{&quot;text&quot;:&quot;default&quot;},&quot;start&quot;:12,&quot;end&quot;:19}]}}
{&quot;type&quot;:&quot;end&quot;,&quot;data&quot;:{&quot;path&quot;:{&quot;text&quot;:&quot;src/lib.rs&quot;},&quot;binary_offset&quot;:null,&quot;stats&quot;:{&quot;elapsed&quot;:{&quot;secs&quot;:0,&quot;nanos&quot;:137622,&quot;human&quot;:&quot;0.000138s&quot;},&quot;searches&quot;:1,&quot;searches_with_match&quot;:1,&quot;bytes_searched&quot;:6064,&quot;bytes_printed&quot;:256,&quot;matched_lines&quot;:1,&quot;matches&quot;:1}}}
{&quot;type&quot;:&quot;begin&quot;,&quot;data&quot;:{&quot;path&quot;:{&quot;text&quot;:&quot;src/components/span.rs&quot;}}}
{&quot;type&quot;:&quot;match&quot;,&quot;data&quot;:{&quot;path&quot;:{&quot;text&quot;:&quot;src/components/span.rs&quot;},&quot;lines&quot;:{&quot;text&quot;:&quot;    Span::default()\n&quot;},&quot;line_number&quot;:6,&quot;absolute_offset&quot;:117,&quot;submatches&quot;:[{&quot;match&quot;:{&quot;text&quot;:&quot;default&quot;},&quot;start&quot;:10,&quot;end&quot;:17}]}}
{&quot;type&quot;:&quot;end&quot;,&quot;data&quot;:{&quot;path&quot;:{&quot;text&quot;:&quot;src/components/span.rs&quot;},&quot;binary_offset&quot;:null,&quot;stats&quot;:{&quot;elapsed&quot;:{&quot;secs&quot;:0,&quot;nanos&quot;:22025,&quot;human&quot;:&quot;0.000022s&quot;},&quot;searches&quot;:1,&quot;searches_with_match&quot;:1,&quot;bytes_searched&quot;:5221,&quot;bytes_printed&quot;:277,&quot;matched_lines&quot;:1,&quot;matches&quot;:1}}}
{&quot;data&quot;:{&quot;elapsed_total&quot;:{&quot;human&quot;:&quot;0.006995s&quot;,&quot;nanos&quot;:6994920,&quot;secs&quot;:0},&quot;stats&quot;:{&quot;bytes_printed&quot;:533,&quot;bytes_searched&quot;:11285,&quot;elapsed&quot;:{&quot;human&quot;:&quot;0.000160s&quot;,&quot;nanos&quot;:159647,&quot;secs&quot;:0},&quot;matched_lines&quot;:2,&quot;matches&quot;:2,&quot;searches&quot;:2,&quot;searches_with_match&quot;:2}},&quot;type&quot;:&quot;summary&quot;}
</code></pre>
<p>如您所见，每个 JSON 文档都是一个包含<code>type</code>字段的对象(map)。这将允许我们为<code>rg</code>编写一个简单前端，读取它们所在的文档，并显示匹配项（以及它们所在的文件）时，即便<em>ripgrep</em>仍在搜索。</p>
<aside>
<p><strong>旁白：</strong> 这就是 Visual Studio Code 的代码搜索，使用的是<em>ripgrep</em>。</p>
</aside>
<a class="header" href="#对人和机器输出的摘要" id="对人和机器输出的摘要"><h2>对人和机器输出的摘要</h2></a>
<p><a href="https://crates.io/crates/convey">convey</a>是一个正在开发的库，它试图让输出消息更容易，以适合人类和机器格式。您定义自己的消息类型，并实现一个<code>Render</code>trait（可在宏的帮助下，手动编写，或者使用派生属性）来说明它们应该如何格式化。目前，它支持打印人类输出（包括，自动检测是否应该上色）、写 JSON 文档（可以是<code>stdout</code>或者指向一个文件）或者是兼顾两者。</p>
<p>即使您不使用这个库，编写一个适合您用例的相仿抽象，也是一个好主意。</p>
<a class="header" href="#如何处理流入我们的输入" id="如何处理流入我们的输入"><h2>如何处理流入我们的输入</h2></a>
<aside class="todo">
<p><strong>TODO：</strong> 讨论如何使用 stdin（请参见<a href="https://github.com/rust-lang-nursery/cli-wg/issues/95">α95</a>）</p>
</aside>
<a class="header" href="#cli-应用程序呈现的文档" id="cli-应用程序呈现的文档"><h1>CLI 应用程序呈现的文档</h1></a>
<p>CLIS 的文档通常包括<code>--help</code>命令，和手册（<code>man</code>）页。</p>
<p>两者都可以在使用<code>clap</code>v3 时自动生成（在未发布的 alpha 中，在编写时），会用到<code>man</code>后端。</p>
<pre><code class="language-rust ignore">#[derive(Clap)]
pub struct Head {
    /// file to load
    #[clap(parse(from_os_str))]
    pub file: PathBuf,
    /// how many lines to print
    #[clap(short = &quot;n&quot;, default_value = &quot;5&quot;)]
    pub count: usize,
}
</code></pre>
<p>其次，您需要使用一个<code>build.rs</code>在编译时，根据应用程序的代码定义生成手册文件。</p>
<p>有一些事情需要记住（例如您希望二进制文件是怎样打包的），但现在我们只需将<code>man</code>文件放到<code>src</code>文件夹旁边。</p>
<pre><code class="language-rust ignore">use clap::IntoApp;
use clap_generate::gen_manuals;

#[path=&quot;src/cli.rs&quot;]
mod cli;

fn main() {
    let app = cli::Head::into_app();
    for man in gen_manuals(&amp;app) {
        let name = &quot;head.1&quot;;
        let mut out = fs::File::create(&quot;head.1&quot;).unwrap();
        use std::io::Write;
        out.write_all(man.render().as_bytes()).unwrap();
    }
}
</code></pre>
<p>现在，你编译应用程序后，<code>head.1</code>文件就会你项目目录中。</p>
<p>如果你用<code>man</code>打开，就能够欣赏您零成本的文档。</p>

                </main>

                <nav class="nav-wrapper" aria-label="Page navigation">
                    <!-- Mobile navigation buttons -->
                    

                    

                    <div style="clear: both"></div>
                </nav>
            </div>
        </div>

        <nav class="nav-wide-wrapper" aria-label="Page navigation">
            

            
        </nav>

    </div>

    

    
    <!-- Google Analytics Tag -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-128555056-1"></script>
    
    <script type="text/javascript">
        var localAddrs = ["localhost", "127.0.0.1", ""];
        if (localAddrs.indexOf(document.location.hostname) === -1) {
            window.dataLayer = window.dataLayer || [];
            function gtag() { dataLayer.push(arguments); }
            gtag('js', new Date());

            gtag('config', 'UA-128555056-1');
        }
    </script>
    

    

    
    <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
    

    <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
    <script src="book.js" type="text/javascript" charset="utf-8"></script>

    <!-- Custom JS scripts -->
    

    
    
    <script type="text/javascript">
        window.addEventListener('load', function () {
            window.setTimeout(window.print, 100);
        });
    </script>
    
    

</body>

</html>